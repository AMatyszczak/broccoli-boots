import {
  derived,
  writable
} from "./chunk-C5ENZSNN.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  check_outros,
  component_subscribe,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_dev,
  onMount,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  svg_element,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-2SWUXKJS.js";

// node_modules/layercake/dist/utils/canBeZero.js
function canBeZero(val) {
  if (val === 0) {
    return true;
  }
  return val;
}

// node_modules/layercake/dist/utils/makeAccessor.js
function makeAccessor(acc) {
  if (!canBeZero(acc))
    return null;
  if (Array.isArray(acc)) {
    return (d) => acc.map((k2) => {
      return typeof k2 !== "function" ? d[k2] : k2(d);
    });
  } else if (typeof acc !== "function") {
    return (d) => d[acc];
  }
  return acc;
}

// node_modules/layercake/dist/utils/filterObject.js
function fromEntries(iter) {
  const obj = {};
  for (const pair of iter) {
    if (Object(pair) !== pair) {
      throw new TypeError("iterable for fromEntries should yield objects");
    }
    const { "0": key, "1": val } = pair;
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: val
    });
  }
  return obj;
}
function filterObject(obj, comparisonObj = {}) {
  return fromEntries(Object.entries(obj).filter(([key, value]) => {
    return value !== void 0 && comparisonObj[key] === void 0;
  }));
}

// node_modules/layercake/dist/utils/debounce.js
function debounce(func, timeout = 300) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, timeout);
  };
}

// node_modules/layercake/dist/lib/calcUniques.js
function calcUniques(data, fields, { sort: sort2 = false } = {}) {
  if (!Array.isArray(data)) {
    throw new TypeError(`The first argument of calcUniques() must be an array. You passed in a ${typeof data}. If you got this error using the <LayerCake> component, consider passing a flat array to the \`flatData\` prop. More info: https://layercake.graphics/guide/#flatdata`);
  }
  if (Array.isArray(fields) || fields === void 0 || fields === null) {
    throw new TypeError("The second argument of calcUniques() must be an object with field names as keys as accessor functions as values.");
  }
  const uniques2 = {};
  const keys = Object.keys(fields);
  const kl = keys.length;
  let i;
  let j;
  let k2;
  let s2;
  let acc;
  let val;
  let set;
  const dl = data.length;
  for (i = 0; i < kl; i += 1) {
    set = /* @__PURE__ */ new Set();
    s2 = keys[i];
    acc = fields[s2];
    for (j = 0; j < dl; j += 1) {
      val = acc(data[j]);
      if (Array.isArray(val)) {
        const vl = val.length;
        for (k2 = 0; k2 < vl; k2 += 1) {
          set.add(val[k2]);
        }
      } else {
        set.add(val);
      }
    }
    const results = Array.from(set);
    uniques2[s2] = sort2 === true ? results.sort() : results;
  }
  return uniques2;
}

// node_modules/layercake/dist/lib/calcExtents.js
function calcExtents(data, fields) {
  if (!Array.isArray(data)) {
    throw new TypeError(`The first argument of calcExtents() must be an array. You passed in a ${typeof data}. If you got this error using the <LayerCake> component, consider passing a flat array to the \`flatData\` prop. More info: https://layercake.graphics/guide/#flatdata`);
  }
  if (Array.isArray(fields) || fields === void 0 || fields === null) {
    throw new TypeError("The second argument of calcExtents() must be an object with field names as keys as accessor functions as values.");
  }
  const extents = {};
  const keys = Object.keys(fields);
  const kl = keys.length;
  let i;
  let j;
  let k2;
  let s2;
  let min3;
  let max3;
  let acc;
  let val;
  const dl = data.length;
  for (i = 0; i < kl; i += 1) {
    s2 = keys[i];
    acc = fields[s2];
    min3 = null;
    max3 = null;
    for (j = 0; j < dl; j += 1) {
      val = acc(data[j]);
      if (Array.isArray(val)) {
        const vl = val.length;
        for (k2 = 0; k2 < vl; k2 += 1) {
          if (val[k2] !== false && val[k2] !== void 0 && val[k2] !== null && Number.isNaN(val[k2]) === false) {
            if (min3 === null || val[k2] < min3) {
              min3 = val[k2];
            }
            if (max3 === null || val[k2] > max3) {
              max3 = val[k2];
            }
          }
        }
      } else if (val !== false && val !== void 0 && val !== null && Number.isNaN(val) === false) {
        if (min3 === null || val < min3) {
          min3 = val;
        }
        if (max3 === null || val > max3) {
          max3 = val;
        }
      }
    }
    extents[s2] = [min3, max3];
  }
  return extents;
}

// node_modules/layercake/dist/utils/arraysEqual.js
function arraysEqual(arr1, arr2) {
  if (arr1.length !== arr2.length)
    return false;
  return arr1.every((k2) => {
    return arr2.includes(k2);
  });
}

// node_modules/layercake/dist/helpers/isOrdinalDomain.js
function isOrdinalDomain(scale) {
  if (typeof scale.bandwidth === "function") {
    return true;
  }
  if (arraysEqual(Object.keys(scale), ["domain", "range", "unknown", "copy"])) {
    return true;
  }
  return false;
}

// node_modules/layercake/dist/helpers/calcScaleExtents.js
function calcScaleExtents(flatData, getters, activeScales) {
  const scaleGroups = Object.keys(activeScales).reduce((groups2, k2) => {
    const domainType = isOrdinalDomain(activeScales[k2]) === true ? "ordinal" : "other";
    if (!groups2[domainType])
      groups2[domainType] = {};
    groups2[domainType][k2] = getters[k2];
    return groups2;
  }, { ordinal: false, other: false });
  let extents = {};
  if (scaleGroups.ordinal) {
    extents = calcUniques(flatData, scaleGroups.ordinal);
  }
  if (scaleGroups.other) {
    extents = { ...extents, ...calcExtents(flatData, scaleGroups.other) };
  }
  return extents;
}

// node_modules/layercake/dist/utils/partialDomain.js
function partialDomain(domain = [], directive) {
  if (Array.isArray(directive) === true) {
    return directive.map((d, i) => {
      if (d === null) {
        return domain[i];
      }
      return d;
    });
  }
  return domain;
}

// node_modules/layercake/dist/helpers/calcDomain.js
function calcDomain(s2) {
  return function domainCalc([$extents, $domain]) {
    if (typeof $domain === "function") {
      $domain = $domain($extents[s2]);
    }
    return $extents ? partialDomain($extents[s2], $domain) : $domain;
  };
}

// node_modules/d3-array/src/ascending.js
function ascending(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x2) => ascending(f2(d), x2);
    delta = (d, x2) => f2(d) - x2;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero;
    compare2 = f2;
    delta = f2;
  }
  function left(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi = a2.length) {
    const i = left(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x2) {
  return x2 === null ? NaN : +x2;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0))
      throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0))
      throw new RangeError("invalid ry");
    let { data: values, width, height } = data;
    if (!((width = Math.floor(width)) >= 0))
      throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values.length / width)) >= 0))
      throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry)
      return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}
function blurh(blur3, T, S, w, h) {
  for (let y2 = 0, n = w * h; y2 < n; ) {
    blur3(T, S, y2, y2 += w, 1);
  }
}
function blurv(blur3, T, S, w, h) {
  for (let x2 = 0, n = w * h; x2 < w; ++x2) {
    blur3(T, S, x2, x2 + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S, start, stop, step) => {
    start <<= 2, stop <<= 2, step <<= 2;
    blur3(T, S, start + 0, stop + 0, step);
    blur3(T, S, start + 1, stop + 1, step);
    blur3(T, S, start + 2, stop + 2, step);
    blur3(T, S, start + 3, stop + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius)
    return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start))
      return;
    let sum3 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum3 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum3 += S[Math.min(stop, i + s0)];
      T[i] = (sum3 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum3 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start))
      return;
    let sum3 = radius * S[start];
    const s2 = step * radius;
    for (let i = start, j = start + s2; i < j; i += step) {
      sum3 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum3 += S[Math.min(stop, i + s2)];
      T[i] = sum3 / w;
      sum3 -= S[Math.max(start, i - s2)];
    }
  };
}

// node_modules/d3-array/src/count.js
function count(values, valueof) {
  let count2 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count2;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
        ++count2;
      }
    }
  }
  return count2;
}

// node_modules/d3-array/src/extent.js
function extent(values, valueof) {
  let min3;
  let max3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min3 === void 0) {
          if (value >= value)
            min3 = max3 = value;
        } else {
          if (min3 > value)
            min3 = value;
          if (max3 < value)
            max3 = value;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null) {
        if (min3 === void 0) {
          if (value >= value)
            min3 = max3 = value;
        } else {
          if (min3 > value)
            min3 = value;
          if (max3 < value)
            max3 = value;
        }
      }
    }
  }
  return [min3, max3];
}

// node_modules/d3-array/src/identity.js
function identity(x2) {
  return x2;
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/constant.js
function constant(x2) {
  return () => x2;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count2) {
  const step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2)
    return tickSpec(start, stop, count2 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  if (!(count2 > 0))
    return [];
  if (start === stop)
    return [start];
  const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count2) : tickSpec(start, stop, count2);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse2) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  return tickSpec(start, stop, count2)[2];
}
function tickStep(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  const reverse2 = stop < start, inc = reverse2 ? tickIncrement(stop, start, count2) : tickIncrement(start, stop, count2);
  return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/nice.js
function nice(start, stop, count2) {
  let prestep;
  while (true) {
    const step = tickIncrement(start, stop, count2);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values) {
  return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/bin.js
function bin() {
  var value = identity, domain = extent, threshold2 = thresholdSturges;
  function histogram(data) {
    if (!Array.isArray(data))
      data = Array.from(data);
    var i, n = data.length, x2, step, values = new Array(n);
    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }
    var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold2(values, x0, x1);
    if (!Array.isArray(tz)) {
      const max3 = x1, tn = +tz;
      if (domain === extent)
        [x0, x1] = nice(x0, x1, tn);
      tz = ticks(x0, x1, tn);
      if (tz[0] <= x0)
        step = tickIncrement(x0, x1, tn);
      if (tz[tz.length - 1] >= x1) {
        if (max3 >= x1 && domain === extent) {
          const step2 = tickIncrement(x0, x1, tn);
          if (isFinite(step2)) {
            if (step2 > 0) {
              x1 = (Math.floor(x1 / step2) + 1) * step2;
            } else if (step2 < 0) {
              x1 = (Math.ceil(x1 * -step2) + 1) / -step2;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m = tz.length, a2 = 0, b = m;
    while (tz[a2] <= x0)
      ++a2;
    while (tz[b - 1] > x1)
      --b;
    if (a2 || b < m)
      tz = tz.slice(a2, b), m = b - a2;
    var bins = new Array(m + 1), bin3;
    for (i = 0; i <= m; ++i) {
      bin3 = bins[i] = [];
      bin3.x0 = i > 0 ? tz[i - 1] : x0;
      bin3.x1 = i < m ? tz[i] : x1;
    }
    if (isFinite(step)) {
      if (step > 0) {
        for (i = 0; i < n; ++i) {
          if ((x2 = values[i]) != null && x0 <= x2 && x2 <= x1) {
            bins[Math.min(m, Math.floor((x2 - x0) / step))].push(data[i]);
          }
        }
      } else if (step < 0) {
        for (i = 0; i < n; ++i) {
          if ((x2 = values[i]) != null && x0 <= x2 && x2 <= x1) {
            const j = Math.floor((x0 - x2) * step);
            bins[Math.min(m, j + (tz[j] <= x2))].push(data[i]);
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x2 = values[i]) != null && x0 <= x2 && x2 <= x1) {
          bins[bisect_default(tz, x2, 0, m)].push(data[i]);
        }
      }
    }
    return bins;
  }
  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };
  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_) {
    return arguments.length ? (threshold2 = typeof _ === "function" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold2;
  };
  return histogram;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array2, i0 = 0, i1 = array2.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array2[m + i0];
      array2[m + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a2) {
  if (a2 <= 0)
    h = s2 = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s2 = NaN;
  else if (s2 <= 0)
    h = NaN;
  return new Hsl(h, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), h = NaN, s2 = max3 - min3, l = (max3 + min3) / 2;
  if (s2) {
    if (r === max3)
      h = (g - b) / s2 + (g < b) * 6;
    else if (g === max3)
      h = (b - r) / s2 + 2;
    else
      h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b)
    x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function lab(l, a2, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity == null ? 1 : opacity);
}
function Lab(l, a2, b, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a2 * (A * cosh2 + B * sinh2)),
      255 * (l + a2 * (C * cosh2 + D * sinh2)),
      255 * (l + a2 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default = (x2) => () => x2;

// node_modules/d3-interpolate/src/color.js
function linear(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
    return Math.pow(a2 + t * b, y2);
  };
}
function hue(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default(isNaN(a2) ? b : a2);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential(a2, b, y2) : constant_default(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d) : constant_default(isNaN(a2) ? b : a2);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a2, b) {
  if (!b)
    b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a2[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x2[i] = value_default(a2[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x2[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a2, b) {
  var d = new Date();
  return a2 = +a2, b = +b, function(t) {
    return d.setTime(a2 * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return a2 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a2, b) {
  var i = {}, c = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = value_default(a2[k2], b[k2]);
    } else {
      c[k2] = b[k2];
    }
  }
  return function(t) {
    for (k2 in i)
      c[k2] = i[k2](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i])
      s2[i] += bs;
    else
      s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a2, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a2, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a2, b, c, d, e, f2) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b * b))
    a2 /= scaleX, b /= scaleX;
  if (skewX = a2 * c + b * d)
    c -= a2 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b * c)
    a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f2,
    rotate: Math.atan2(b, a2) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity2 : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity2;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity2;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a2, b, s2, q) {
    if (a2 !== b) {
      if (a2 - b > 180)
        b += 360;
      else if (b - a2 > 180)
        a2 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a2, b, s2, q) {
    if (a2 !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b) {
    var s2 = [], q = [];
    a2 = parse(a2), b = parse(b);
    translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
    rotate(a2.rotate, b.rotate, s2, q);
    skewX(a2.skewX, b.skewX, s2, q);
    scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
    a2 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s2 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s2(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s2(t);
        start.l = l(Math.pow(t, y2));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale/src/constant.js
function constants(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-scale/src/number.js
function number2(x2) {
  return +x2;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x2) {
  return x2;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a2, b) {
  var t;
  if (a2 > b)
    t = a2, a2 = b, b = t;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap(domain, range2, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range2, interpolate) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range2[i], range2[i + 1]);
  }
  return function(x2) {
    var i2 = bisect_default(domain, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate = value_default, transform, untransform, unknown, clamp = identity3, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp !== identity3)
      clamp = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform), range2, interpolate)))(transform(clamp(x2)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform), number_default)))(y2)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity3, rescale()) : clamp !== identity3;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity3, identity3);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x2, p) => (x2 * 100).toFixed(p),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal_default,
  "e": (x2, p) => x2.toExponential(p),
  "f": (x2, p) => x2.toFixed(p),
  "g": (x2, p) => x2.toPrecision(p),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p) => formatRounded_default(x2 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x2) {
  return x2;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes_default[type])
      precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero3 || fill === "0" && align === "=")
      zero3 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3)
        value = group2(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero3)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f2(k2 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max3) {
  step = Math.abs(step), max3 = Math.abs(max3) - step;
  return Math.max(0, exponent_default(max3) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count2, specifier) {
  var step = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent) : Math.pow(x2, exponent);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform) {
  var scale = transform(identity3, identity3), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform(identity3, identity3) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
  }
  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale);
}
function pow() {
  var scale = powish(transformer());
  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-time/src/interval.js
var t02 = new Date();
var t12 = new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
  }
  interval.floor = (date) => {
    return floori(date = new Date(+date)), date;
  };
  interval.ceil = (date) => {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };
  interval.round = (date) => {
    const d0 = interval(date), d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };
  interval.offset = (date, step) => {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };
  interval.range = (start, stop, step) => {
    const range2 = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0))
      return range2;
    let previous;
    do
      range2.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range2;
  };
  interval.filter = (test) => {
    return timeInterval((date) => {
      if (date >= date)
        while (floori(date), !test(date))
          date.setTime(date - 1);
    }, (date, step) => {
      if (date >= date) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date, 1), !test(date)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval.count = (start, end) => {
      t02.setTime(+start), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
    };
  }
  return interval;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date, step) => {
  date.setTime(+date + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0))
    return null;
  if (!(k2 > 1))
    return millisecond;
  return timeInterval((date) => {
    date.setTime(Math.floor(date / k2) * k2);
  }, (date, step) => {
    date.setTime(+date + step * k2);
  }, (start, end) => {
    return (end - start) / k2;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds());
}, (date, step) => {
  date.setTime(+date + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date) => {
  return date.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date) => {
  date.setUTCSeconds(0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date) => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date) => date.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return Math.floor(date / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date) => {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setDate(date.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setMonth(date.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date) => {
  return date.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCMonth(date.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date) => {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setFullYear(date.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date) => {
  return date.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date) => {
    date.setFullYear(Math.floor(date.getFullYear() / k2) * k2);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setFullYear(date.getFullYear() + step * k2);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date) => {
  return date.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date) => {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k2) * k2);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCFullYear(date.getUTCFullYear() + step * k2);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop, count2) {
    const reverse2 = stop < start;
    if (reverse2)
      [start, stop] = [stop, start];
    const interval = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop, count2);
    const ticks3 = interval ? interval.range(start, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count2) {
    const target = Math.abs(stop - start) / count2;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length)
      return year.every(tickStep(start / durationYear, stop / durationYear, count2));
    if (i === 0)
      return millisecond.every(Math.max(tickStep(start, stop, count2), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date) {
      var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format2;
      if (!(date instanceof Date))
        date = new Date(+date);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad2 = pads[c = specifier.charAt(++i)]) != null)
            c = specifier.charAt(++i);
          else
            pad2 = c === "e" ? " " : "0";
          if (format2 = formats2[c])
            c = format2(date, pad2);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c, parse;
    while (i < n) {
      if (j >= m)
        return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0)
          return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f2 = newFormat(specifier += "", formats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f2 = newFormat(specifier += "", utcFormats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign2 = value < 0 ? "-" : "", string = (sign2 ? -value : value) + "", length = string.length;
  return sign2 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date) {
  return date.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}
var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/layercake/dist/settings/defaultScales.js
var defaultScales_default = {
  x: linear2,
  y: linear2,
  z: linear2,
  r: sqrt
};

// node_modules/layercake/dist/helpers/findScaleType.js
function findScaleType(scale) {
  if (scale.constant) {
    return "symlog";
  }
  if (scale.base) {
    return "log";
  }
  if (scale.exponent) {
    if (scale.exponent() === 0.5) {
      return "sqrt";
    }
    return "pow";
  }
  return "other";
}

// node_modules/layercake/dist/utils/identity.js
function identity5(d) {
  return d;
}

// node_modules/layercake/dist/helpers/getPadFunctions.js
function log2(sign2) {
  return (x2) => Math.log(sign2 * x2);
}
function exp(sign2) {
  return (x2) => sign2 * Math.exp(x2);
}
function symlog2(c) {
  return (x2) => Math.sign(x2) * Math.log1p(Math.abs(x2 / c));
}
function symexp(c) {
  return (x2) => Math.sign(x2) * Math.expm1(Math.abs(x2)) * c;
}
function pow2(exponent) {
  return function powFn(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent) : Math.pow(x2, exponent);
  };
}
function getPadFunctions(scale) {
  const scaleType = findScaleType(scale);
  if (scaleType === "log") {
    const sign2 = Math.sign(scale.domain()[0]);
    return { lift: log2(sign2), ground: exp(sign2), scaleType };
  }
  if (scaleType === "pow") {
    const exponent = 1;
    return { lift: pow2(exponent), ground: pow2(1 / exponent), scaleType };
  }
  if (scaleType === "sqrt") {
    const exponent = 0.5;
    return { lift: pow2(exponent), ground: pow2(1 / exponent), scaleType };
  }
  if (scaleType === "symlog") {
    const constant2 = 1;
    return { lift: symlog2(constant2), ground: symexp(constant2), scaleType };
  }
  return { lift: identity5, ground: identity5, scaleType };
}

// node_modules/layercake/dist/helpers/toTitleCase.js
function toTitleCase(str) {
  return str.replace(/^\w/, (d) => d.toUpperCase());
}

// node_modules/layercake/dist/helpers/findScaleName.js
function f(name, modifier = "") {
  return `scale${toTitleCase(modifier)}${toTitleCase(name)}`;
}
function findScaleName(scale) {
  if (typeof scale.bandwidth === "function") {
    if (typeof scale.paddingInner === "function") {
      return f("band");
    }
    return f("point");
  }
  if (arraysEqual(Object.keys(scale), ["domain", "range", "unknown", "copy"])) {
    return f("ordinal");
  }
  let modifier = "";
  if (scale.interpolator) {
    if (scale.domain().length === 3) {
      modifier = "diverging";
    } else {
      modifier = "sequential";
    }
  }
  if (scale.quantiles) {
    return f("quantile", modifier);
  }
  if (scale.thresholds) {
    return f("quantize", modifier);
  }
  if (scale.constant) {
    return f("symlog", modifier);
  }
  if (scale.base) {
    return f("log", modifier);
  }
  if (scale.exponent) {
    if (scale.exponent() === 0.5) {
      return f("sqrt", modifier);
    }
    return f("pow", modifier);
  }
  if (arraysEqual(Object.keys(scale), ["domain", "range", "invertExtent", "unknown", "copy"])) {
    return f("threshold");
  }
  if (arraysEqual(Object.keys(scale), ["invert", "range", "domain", "unknown", "copy", "ticks", "tickFormat", "nice"])) {
    return f("identity");
  }
  if (arraysEqual(Object.keys(scale), [
    "invert",
    "domain",
    "range",
    "rangeRound",
    "round",
    "clamp",
    "unknown",
    "copy",
    "ticks",
    "tickFormat",
    "nice"
  ])) {
    return f("radial");
  }
  if (modifier) {
    return f(modifier);
  }
  if (scale.domain()[0] instanceof Date) {
    const d = new Date();
    let s2;
    d.getDay = () => s2 = "time";
    d.getUTCDay = () => s2 = "utc";
    scale.tickFormat(0, "%a")(d);
    return f(s2);
  }
  return f("linear");
}

// node_modules/layercake/dist/utils/padScale.js
var unpaddable = ["scaleThreshold", "scaleQuantile", "scaleQuantize", "scaleSequentialQuantile"];
function padScale(scale, padding) {
  if (typeof scale.range !== "function") {
    console.log(scale);
    throw new Error("Scale method `range` must be a function");
  }
  if (typeof scale.domain !== "function") {
    throw new Error("Scale method `domain` must be a function");
  }
  if (!Array.isArray(padding) || unpaddable.includes(findScaleName(scale))) {
    return scale.domain();
  }
  if (isOrdinalDomain(scale) === true) {
    return scale.domain();
  }
  const { lift, ground } = getPadFunctions(scale);
  const d0 = scale.domain()[0];
  const isTime = Object.prototype.toString.call(d0) === "[object Date]";
  const [d1, d2] = scale.domain().map((d) => {
    return isTime ? lift(d.getTime()) : lift(d);
  });
  const [r1, r2] = scale.range();
  const paddingLeft = padding[0] || 0;
  const paddingRight = padding[1] || 0;
  const step = (d2 - d1) / (Math.abs(r2 - r1) - paddingLeft - paddingRight);
  return [d1 - paddingLeft * step, paddingRight * step + d2].map((d) => {
    return isTime ? ground(new Date(d)) : ground(d);
  });
}

// node_modules/layercake/dist/settings/getDefaultRange.js
function calcBaseRange(s2, width, height, reverse2, percentRange) {
  let min3;
  let max3;
  if (percentRange === true) {
    min3 = 0;
    max3 = 100;
  } else {
    min3 = s2 === "r" ? 1 : 0;
    max3 = s2 === "y" ? height : s2 === "r" ? 25 : width;
  }
  return reverse2 === true ? [max3, min3] : [min3, max3];
}
function getDefaultRange(s2, width, height, reverse2, range2, percentRange) {
  return !range2 ? calcBaseRange(s2, width, height, reverse2, percentRange) : typeof range2 === "function" ? range2({ width, height }) : range2;
}

// node_modules/layercake/dist/helpers/createScale.js
function createScale(s2) {
  return function scaleCreator([$scale, $extents, $domain, $padding, $nice, $reverse, $width, $height, $range, $percentScale]) {
    if ($extents === null) {
      return null;
    }
    const defaultRange = getDefaultRange(s2, $width, $height, $reverse, $range, $percentScale);
    const scale = $scale === defaultScales_default[s2] ? $scale() : $scale.copy();
    scale.domain($domain);
    if (!scale.interpolator || typeof scale.interpolator === "function" && scale.interpolator().name.startsWith("identity")) {
      scale.range(defaultRange);
    }
    if ($padding) {
      scale.domain(padScale(scale, $padding));
    }
    if ($nice === true || typeof $nice === "number") {
      if (typeof scale.nice === "function") {
        scale.nice(typeof $nice === "number" ? $nice : void 0);
      } else {
        console.error(`[Layer Cake] You set \`${s2}Nice: true\` but the ${s2}Scale does not have a \`.nice\` method. Ignoring...`);
      }
    }
    return scale;
  };
}

// node_modules/layercake/dist/helpers/createGetter.js
function createGetter([$acc, $scale]) {
  return (d) => {
    const val = $acc(d);
    if (Array.isArray(val)) {
      return val.map((v) => $scale(v));
    }
    return $scale(val);
  };
}

// node_modules/layercake/dist/helpers/getRange.js
function getRange([$scale]) {
  if (typeof $scale === "function") {
    if (typeof $scale.range === "function") {
      return $scale.range();
    }
    console.error("[LayerCake] Your scale doesn't have a `.range` method?");
  }
  return null;
}

// node_modules/layercake/dist/helpers/printDebug.js
var indent = "    ";
function getRgb(clr) {
  const { r, g, b, opacity: o } = rgb(clr);
  if (![r, g, b].every((c) => c >= 0 && c <= 255)) {
    return false;
  }
  return { r, g, b, o };
}
function contrast({ r, g, b }) {
  const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
  return luminance > 0.6 ? "black" : "white";
}
function printDebug(obj) {
  console.log("/********* LayerCake Debug ************/");
  console.log("Bounding box:");
  printObject(obj.boundingBox);
  console.log("Scales:\n");
  Object.keys(obj.activeGetters).forEach((g) => {
    printScale(g, obj[`${g}Scale`], obj[g]);
  });
  console.log("/************ End LayerCake Debug ***************/\n");
}
function printObject(obj) {
  Object.entries(obj).forEach(([key, value]) => {
    console.log(`${indent}${key}:`, value);
  });
}
function printScale(s2, scale, acc) {
  const scaleName = findScaleName(scale);
  console.log(`${indent}${s2}:`);
  console.log(`${indent}${indent}Accessor: "${acc.toString()}"`);
  console.log(`${indent}${indent}Type: ${scaleName}`);
  printValues(scale, "domain");
  printValues(scale, "range", " ");
}
function printValues(scale, method, extraSpace = "") {
  const values = scale[method]();
  const colorValues = colorizeArray(values);
  if (colorValues) {
    printColorArray(colorValues, method, values);
  } else {
    console.log(`${indent}${indent}${toTitleCase(method)}:${extraSpace}`, values);
  }
}
function printColorArray(colorValues, method, values) {
  console.log(
    `${indent}${indent}${toTitleCase(method)}:    %cArray%c(${values.length}) ` + colorValues[0] + "%c ]",
    "color: #1377e4",
    "color: #737373",
    "color: #1478e4",
    ...colorValues[1],
    "color: #1478e4"
  );
}
function colorizeArray(arr) {
  const colors = [];
  const a2 = arr.map((d, i) => {
    const rgbo = getRgb(d);
    if (rgbo !== false) {
      colors.push(rgbo);
      const space2 = i === arr.length - 1 ? " " : "";
      return `%c ${d}${space2}`;
    }
    return d;
  });
  if (colors.length) {
    return [
      `%c[ ${a2.join(", ")}`,
      colors.map(
        (d) => `background-color: rgba(${d.r}, ${d.g}, ${d.b}, ${d.o}); color:${contrast(d)};`
      )
    ];
  }
  return null;
}

// node_modules/layercake/dist/LayerCake.svelte
var { Object: Object_1, console: console_1 } = globals;
var file = "node_modules/layercake/dist/LayerCake.svelte";
function add_css(target) {
  append_styles(target, "svelte-vhzpsp", ".layercake-container.svelte-vhzpsp,.layercake-container.svelte-vhzpsp *{box-sizing:border-box}.layercake-container.svelte-vhzpsp{width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGF5ZXJDYWtlLnN2ZWx0ZSIsInNvdXJjZXMiOlsiTGF5ZXJDYWtlLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG5cdEBjb21wb25lbnRcblx0TGF5ZXIgQ2FrZSBjb21wb25lbnRcbiAtLT5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IHNldENvbnRleHQsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyB3cml0YWJsZSwgZGVyaXZlZCB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG5cblx0aW1wb3J0IG1ha2VBY2Nlc3NvciBmcm9tICcuL3V0aWxzL21ha2VBY2Nlc3Nvci5qcyc7XG5cdGltcG9ydCBmaWx0ZXJPYmplY3QgZnJvbSAnLi91dGlscy9maWx0ZXJPYmplY3QuanMnO1xuXHRpbXBvcnQgZGVib3VuY2UgZnJvbSAnLi91dGlscy9kZWJvdW5jZS5qcyc7XG5cblx0aW1wb3J0IGNhbGNTY2FsZUV4dGVudHMgZnJvbSAnLi9oZWxwZXJzL2NhbGNTY2FsZUV4dGVudHMuanMnO1xuXHRpbXBvcnQgY2FsY0RvbWFpbiBmcm9tICcuL2hlbHBlcnMvY2FsY0RvbWFpbi5qcyc7XG5cdGltcG9ydCBjcmVhdGVTY2FsZSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlU2NhbGUuanMnO1xuXHRpbXBvcnQgY3JlYXRlR2V0dGVyIGZyb20gJy4vaGVscGVycy9jcmVhdGVHZXR0ZXIuanMnO1xuXHRpbXBvcnQgZ2V0UmFuZ2UgZnJvbSAnLi9oZWxwZXJzL2dldFJhbmdlLmpzJztcblx0aW1wb3J0IHByaW50RGVidWcgZnJvbSAnLi9oZWxwZXJzL3ByaW50RGVidWcuanMnO1xuXG5cdGltcG9ydCBkZWZhdWx0U2NhbGVzIGZyb20gJy4vc2V0dGluZ3MvZGVmYXVsdFNjYWxlcy5qcyc7XG5cblx0Y29uc3QgcHJpbnREZWJ1Z19kZWJvdW5jZWQgPSBkZWJvdW5jZShwcmludERlYnVnLCAyMDApO1xuXG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gW3Nzcj1mYWxzZV0gV2hldGhlciB0aGlzIGNoYXJ0IHNob3VsZCBiZSByZW5kZXJlZCBzZXJ2ZXIgc2lkZS4gKi9cblx0ZXhwb3J0IGxldCBzc3IgPSBmYWxzZTtcblx0LyoqIEB0eXBlIHtCb29sZWFufSBbcG9pbnRlckV2ZW50cz10cnVlXSBXaGV0aGVyIHRvIGFsbG93IHBvaW50ZXIgZXZlbnRzIHZpYSBDU1MuIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZTtgIG9uIGFsbCBjb21wb25lbnRzLCBkaXNhYmxpbmcgYWxsIG1vdXNlIGludGVyYWN0aW9uLiAqL1xuXHRleHBvcnQgbGV0IHBvaW50ZXJFdmVudHMgPSB0cnVlO1xuXHQvKiogQHR5cGUge1N0cmluZ30gW3Bvc2l0aW9uPSdyZWxhdGl2ZSddIERldGVybWluZSB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIHdyYXBwZXIgZGl2LiBTZXQgdGhpcyB0byBgJ2Fic29sdXRlJ2Agd2hlbiB5b3Ugd2FudCB0byBzdGFjayBjYWtlcy4gKi9cblx0ZXhwb3J0IGxldCBwb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gW3BlcmNlbnRSYW5nZT1mYWxzZV0gSWYgYHRydWVgLCBzZXQgYWxsIHNjYWxlIHJhbmdlcyB0byBgWzAsIDEwMF1gLiBSYW5nZXMgcmV2ZXJzZWQgdmlhIGB4UmV2ZXJzZWAsIGB5UmV2ZXJzZWAsIGB6UmV2ZXJzZWAgb3IgYHJSZXZlcnNlYCBwcm9wcyB3aWxsIGNvbnRpbnVlIHRvIGJlIHJldmVyc2VkIGFzIHVzdWFsLiAqL1xuXHRleHBvcnQgbGV0IHBlcmNlbnRSYW5nZSA9IGZhbHNlO1xuXG5cdC8qKiBAdHlwZSB7TnVtYmVyfSBbd2lkdGg9Y29udGFpbmVyV2lkdGhdIE92ZXJyaWRlIHRoZSBhdXRvbWF0ZWQgd2lkdGguICovXG5cdGV4cG9ydCBsZXQgd2lkdGggPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7TnVtYmVyfSBbaGVpZ2h0PWNvbnRhaW5lckhlaWdodF0gT3ZlcnJpZGUgdGhlIGF1dG9tYXRlZCBoZWlnaHQuICovXG5cdGV4cG9ydCBsZXQgaGVpZ2h0ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7TnVtYmVyfSBbY29udGFpbmVyV2lkdGg9MTAwXSBUaGUgYm91bmQgY29udGFpbmVyIHdpZHRoLiAqL1xuXHRleHBvcnQgbGV0IGNvbnRhaW5lcldpZHRoID0gd2lkdGggfHwgMTAwO1xuXHQvKiogQHR5cGUge051bWJlcn0gW2NvbnRhaW5lckhlaWdodD0xMDBdIFRoZSBib3VuZCBjb250YWluZXIgaGVpZ2h0LiAqL1xuXHRleHBvcnQgbGV0IGNvbnRhaW5lckhlaWdodCA9IGhlaWdodCB8fCAxMDA7XG5cblx0LyoqXHRAdHlwZSB7RWxlbWVudH0gW2VsZW1lbnRdIFRoZSAubGF5ZXJjYWtlLWNvbnRhaW5lciBgPGRpdj5gIHRhZy4gVXNlZnVsIGZvciBiaW5kaW5ncy4gKi9cblx0ZXhwb3J0IGxldCBlbGVtZW50ID0gdW5kZWZpbmVkO1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIFBhcmFtZXRlcnNcblx0ICogVmFsdWVzIHRoYXQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYmFzZWQgb24gYW5kIHRoYXRcblx0ICogY2FuIGJlIGVhc2lseSBleHRlbmRlZCBmcm9tIGNvbmZpZyB2YWx1ZXNcblx0ICpcblx0ICovXG5cblx0LyoqIEB0eXBlIHtTdHJpbmd8RnVuY3Rpb258TnVtYmVyfEFycmF5fSB4IFRoZSB4IGFjY2Vzc29yLiBUaGUga2V5IGluIGVhY2ggcm93IG9mIGRhdGEgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgeC1maWVsZC4gVGhpcyBjYW4gYmUgYSBzdHJpbmcsIGFuIGFjY2Vzc29yIGZ1bmN0aW9uLCBhIG51bWJlciBvciBhbiBhcnJheSBvZiBhbnkgY29tYmluYXRpb24gb2YgdGhvc2UgdHlwZXMuIFRoaXMgcHJvcGVydHkgZ2V0cyBjb252ZXJ0ZWQgdG8gYSBmdW5jdGlvbiB3aGVuIHlvdSBhY2Nlc3MgaXQgdGhyb3VnaCB0aGUgY29udGV4dC4gKi9cblx0ZXhwb3J0IGxldCB4ID0gdW5kZWZpbmVkO1xuXHQvKiogQHR5cGUge1N0cmluZ3xGdW5jdGlvbnxOdW1iZXJ8QXJyYXl9IHkgVGhlIHkgYWNjZXNzb3IuIFRoZSBrZXkgaW4gZWFjaCByb3cgb2YgZGF0YSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB5LWZpZWxkLiBUaGlzIGNhbiBiZSBhIHN0cmluZywgYW4gYWNjZXNzb3IgZnVuY3Rpb24sIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGFueSBjb21iaW5hdGlvbiBvZiB0aG9zZSB0eXBlcy4gVGhpcyBwcm9wZXJ0eSBnZXRzIGNvbnZlcnRlZCB0byBhIGZ1bmN0aW9uIHdoZW4geW91IGFjY2VzcyBpdCB0aHJvdWdoIHRoZSBjb250ZXh0LiAqL1xuXHRleHBvcnQgbGV0IHkgPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufE51bWJlcnxBcnJheX0geiBUaGUgeiBhY2Nlc3Nvci4gVGhlIGtleSBpbiBlYWNoIHJvdyBvZiBkYXRhIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHotZmllbGQuIFRoaXMgY2FuIGJlIGEgc3RyaW5nLCBhbiBhY2Nlc3NvciBmdW5jdGlvbiwgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgYW55IGNvbWJpbmF0aW9uIG9mIHRob3NlIHR5cGVzLiBUaGlzIHByb3BlcnR5IGdldHMgY29udmVydGVkIHRvIGEgZnVuY3Rpb24gd2hlbiB5b3UgYWNjZXNzIGl0IHRocm91Z2ggdGhlIGNvbnRleHQuICovXG5cdGV4cG9ydCBsZXQgeiA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtTdHJpbmd8RnVuY3Rpb258TnVtYmVyfEFycmF5fSByIFRoZSByIGFjY2Vzc29yLiBUaGUga2V5IGluIGVhY2ggcm93IG9mIGRhdGEgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgci1maWVsZC4gVGhpcyBjYW4gYmUgYSBzdHJpbmcsIGFuIGFjY2Vzc29yIGZ1bmN0aW9uLCBhIG51bWJlciBvciBhbiBhcnJheSBvZiBhbnkgY29tYmluYXRpb24gb2YgdGhvc2UgdHlwZXMuIFRoaXMgcHJvcGVydHkgZ2V0cyBjb252ZXJ0ZWQgdG8gYSBmdW5jdGlvbiB3aGVuIHlvdSBhY2Nlc3MgaXQgdGhyb3VnaCB0aGUgY29udGV4dC4gKi9cblx0ZXhwb3J0IGxldCByID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7QXJyYXl8T2JqZWN0fSBbZGF0YT1bXV0gSWYgYGRhdGFgIGlzIG5vdCBhIGZsYXQgYXJyYXkgb2Ygb2JqZWN0cyBhbmQgeW91IHdhbnQgdG8gdXNlIGFueSBvZiB0aGUgc2NhbGVzLCBzZXQgYSBmbGF0IHZlcnNpb24gb2YgdGhlIGRhdGEgdmlhIHRoZSBgZmxhdERhdGFgIHByb3AuICovXG5cdGV4cG9ydCBsZXQgZGF0YSA9IFtdO1xuXG5cdC8qKiBAdHlwZSB7W21pbjogTnVtYmVyfG51bGwsIG1heDogTnVtYmVyfG51bGxdfFN0cmluZ1tdfE51bWJlcltdfEZ1bmN0aW9ufSBbeERvbWFpbl0gU2V0IGEgbWluIG9yIG1heC4gRm9yIGxpbmVhciBzY2FsZXMsIGlmIHlvdSB3YW50IHRvIGluaGVyaXQgdGhlIHZhbHVlIGZyb20gdGhlIGRhdGEncyBleHRlbnQsIHNldCB0aGF0IHZhbHVlIHRvIGBudWxsYC4gVGhpcyB2YWx1ZSBjYW4gYWxzbyBiZSBhbiBhcnJheSBiZWNhdXNlIHNvbWV0aW1lcyB5b3VyIHNjYWxlcyBhcmUgW3BpZWNld2lzZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI2NvbnRpbnVvdXNfZG9tYWluKSBvciBhcmUgYSBsaXN0IG9mIGRpc2NyZXRlIHZhbHVlcyBzdWNoIGFzIGluIFtvcmRpbmFsIHNjYWxlc10oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI29yZGluYWwtc2NhbGVzKSwgdXNlZnVsIGZvciBjb2xvciBzZXJpZXMuIFNldCBpdCB0byBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGNvbXB1dGVkIGRvbWFpbiBhbmQgbGV0cyB5b3UgcmV0dXJuIGEgbW9kaWZpZWQgZG9tYWluLCB1c2VmdWwgZm9yIHNvcnRpbmcgdmFsdWVzLiAqL1xuXHRleHBvcnQgbGV0IHhEb21haW4gPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7W21pbjogTnVtYmVyfG51bGwsIG1heDogTnVtYmVyfG51bGxdfFN0cmluZ1tdfE51bWJlcltdfEZ1bmN0aW9ufSBbeURvbWFpbl0gU2V0IGEgbWluIG9yIG1heC4gRm9yIGxpbmVhciBzY2FsZXMsIGlmIHlvdSB3YW50IHRvIGluaGVyaXQgdGhlIHZhbHVlIGZyb20gdGhlIGRhdGEncyBleHRlbnQsIHNldCB0aGF0IHZhbHVlIHRvIGBudWxsYC4gIFNldCBpdCB0byBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGNvbXB1dGVkIGRvbWFpbiBhbmQgbGV0cyB5b3UgcmV0dXJuIGEgbW9kaWZpZWQgZG9tYWluLCB1c2VmdWwgZm9yIHNvcnRpbmcgdmFsdWVzLiAqL1xuXHRleHBvcnQgbGV0IHlEb21haW4gPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7W21pbjogTnVtYmVyfG51bGwsIG1heDogTnVtYmVyfG51bGxdfFN0cmluZ1tdfE51bWJlcltdfEZ1bmN0aW9ufSBbekRvbWFpbl0gU2V0IGEgbWluIG9yIG1heC4gRm9yIGxpbmVhciBzY2FsZXMsIGlmIHlvdSB3YW50IHRvIGluaGVyaXQgdGhlIHZhbHVlIGZyb20gdGhlIGRhdGEncyBleHRlbnQsIHNldCB0aGF0IHZhbHVlIHRvIGBudWxsYC4gVGhpcyB2YWx1ZSBjYW4gYWxzbyBiZSBhbiBhcnJheSBiZWNhdXNlIHNvbWV0aW1lcyB5b3VyIHNjYWxlcyBhcmUgW3BpZWNld2lzZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI2NvbnRpbnVvdXNfZG9tYWluKSBvciBhcmUgYSBsaXN0IG9mIGRpc2NyZXRlIHZhbHVlcyBzdWNoIGFzIGluIFtvcmRpbmFsIHNjYWxlc10oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI29yZGluYWwtc2NhbGVzKSwgdXNlZnVsIGZvciBjb2xvciBzZXJpZXMuIFNldCBpdCB0byBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGNvbXB1dGVkIGRvbWFpbiBhbmQgbGV0cyB5b3UgcmV0dXJuIGEgbW9kaWZpZWQgZG9tYWluLCB1c2VmdWwgZm9yIHNvcnRpbmcgdmFsdWVzLiAqL1xuXHRleHBvcnQgbGV0IHpEb21haW4gPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7W21pbjogTnVtYmVyfG51bGwsIG1heDogTnVtYmVyfG51bGxdfFN0cmluZ1tdfE51bWJlcltdfEZ1bmN0aW9ufSBbckRvbWFpbl0gU2V0IGEgbWluIG9yIG1heC4gRm9yIGxpbmVhciBzY2FsZXMsIGlmIHlvdSB3YW50IHRvIGluaGVyaXQgdGhlIHZhbHVlIGZyb20gdGhlIGRhdGEncyBleHRlbnQsIHNldCB0aGF0IHZhbHVlIHRvIGBudWxsYC4gVGhpcyB2YWx1ZSBjYW4gYWxzbyBiZSBhbiBhcnJheSBiZWNhdXNlIHNvbWV0aW1lcyB5b3VyIHNjYWxlcyBhcmUgW3BpZWNld2lzZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI2NvbnRpbnVvdXNfZG9tYWluKSBvciBhcmUgYSBsaXN0IG9mIGRpc2NyZXRlIHZhbHVlcyBzdWNoIGFzIGluIFtvcmRpbmFsIHNjYWxlc10oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI29yZGluYWwtc2NhbGVzKSwgdXNlZnVsIGZvciBjb2xvciBzZXJpZXMuIFNldCBpdCB0byBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGNvbXB1dGVkIGRvbWFpbiBhbmQgbGV0cyB5b3UgcmV0dXJuIGEgbW9kaWZpZWQgZG9tYWluLCB1c2VmdWwgZm9yIHNvcnRpbmcgdmFsdWVzLiAqL1xuXHRleHBvcnQgbGV0IHJEb21haW4gPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7Qm9vbGVhbnxOdW1iZXJ9IFt4TmljZT1mYWxzZV0gQXBwbGllcyBEMydzIFtzY2FsZS5uaWNlKCldKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNjb250aW51b3VzX25pY2UpIHRvIHRoZSB4IGRvbWFpbi4gKi9cblx0ZXhwb3J0IGxldCB4TmljZSA9IGZhbHNlO1xuXHQvKiogQHR5cGUge0Jvb2xlYW58TnVtYmVyfSBbeU5pY2U9ZmFsc2VdIEFwcGxpZXMgRDMncyBbc2NhbGUubmljZSgpXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19uaWNlKSB0byB0aGUgeSBkb21haW4uICovXG5cdGV4cG9ydCBsZXQgeU5pY2UgPSBmYWxzZTtcblx0LyoqIEB0eXBlIHtCb29sZWFufE51bWJlcn0gW3pOaWNlPWZhbHNlXSBBcHBsaWVzIEQzJ3MgW3NjYWxlLm5pY2UoKV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI2NvbnRpbnVvdXNfbmljZSkgdG8gdGhlIHogZG9tYWluLiAqL1xuXHRleHBvcnQgbGV0IHpOaWNlID0gZmFsc2U7XG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gW3JOaWNlPWZhbHNlXSBBcHBsaWVzIEQzJ3MgW3NjYWxlLm5pY2UoKV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI2NvbnRpbnVvdXNfbmljZSkgdG8gdGhlIHIgZG9tYWluLiAqL1xuXHRleHBvcnQgbGV0IHJOaWNlID0gZmFsc2U7XG5cdC8qKiBAdHlwZSB7W2xlZnRQaXhlbHM6IE51bWJlciwgcmlnaHRQaXhlbHM6IE51bWJlcl19IFt4UGFkZGluZ10gQXNzaWduIGEgcGl4ZWwgdmFsdWUgdG8gYWRkIHRvIHRoZSBtaW4gb3IgbWF4IG9mIHRoZSBzY2FsZS4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBzY2FsZXMgZG9tYWluIGJ5IHRoZSBzY2FsZSB1bml0IGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIHBpeGVscy4gKi9cblx0ZXhwb3J0IGxldCB4UGFkZGluZyA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtbbGVmdFBpeGVsczogTnVtYmVyLCByaWdodFBpeGVsczogTnVtYmVyXX0gW3lQYWRkaW5nXSBBc3NpZ24gYSBwaXhlbCB2YWx1ZSB0byBhZGQgdG8gdGhlIG1pbiBvciBtYXggb2YgdGhlIHNjYWxlLiBUaGlzIHdpbGwgaW5jcmVhc2UgdGhlIHNjYWxlcyBkb21haW4gYnkgdGhlIHNjYWxlIHVuaXQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgcGl4ZWxzLiAqL1xuXHRleHBvcnQgbGV0IHlQYWRkaW5nID0gdW5kZWZpbmVkO1xuXHQvKiogQHR5cGUge1tsZWZ0UGl4ZWxzOiBOdW1iZXIsIHJpZ2h0UGl4ZWxzOiBOdW1iZXJdfSBbelBhZGRpbmddIEFzc2lnbiBhIHBpeGVsIHZhbHVlIHRvIGFkZCB0byB0aGUgbWluIG9yIG1heCBvZiB0aGUgc2NhbGUuIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgc2NhbGVzIGRvbWFpbiBieSB0aGUgc2NhbGUgdW5pdCBlcXVpdmFsZW50IG9mIHRoZSBwcm92aWRlZCBwaXhlbHMuICovXG5cdGV4cG9ydCBsZXQgelBhZGRpbmcgPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7W2xlZnRQaXhlbHM6IE51bWJlciwgcmlnaHRQaXhlbHM6IE51bWJlcl19IFtyUGFkZGluZ10gQXNzaWduIGEgcGl4ZWwgdmFsdWUgdG8gYWRkIHRvIHRoZSBtaW4gb3IgbWF4IG9mIHRoZSBzY2FsZS4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBzY2FsZXMgZG9tYWluIGJ5IHRoZSBzY2FsZSB1bml0IGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIHBpeGVscy4gKi9cblx0ZXhwb3J0IGxldCByUGFkZGluZyA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtGdW5jdGlvbn0gW3hTY2FsZT1kMy5zY2FsZUxpbmVhcl0gVGhlIEQzIHNjYWxlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSB4LWRpbWVuc2lvbi4gUGFzcyBpbiBhbiBpbnN0YW50aWF0ZWQgRDMgc2NhbGUgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3IgeW91IHdhbnQgdG8gZXh0cmEgb3B0aW9ucy4gKi9cblx0ZXhwb3J0IGxldCB4U2NhbGUgPSBkZWZhdWx0U2NhbGVzLng7XG5cdC8qKiBAdHlwZSB7RnVuY3Rpb259IFt5U2NhbGU9ZDMuc2NhbGVMaW5lYXJdIFRoZSBEMyBzY2FsZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgeC1kaW1lbnNpb24uIFBhc3MgaW4gYW4gaW5zdGFudGlhdGVkIEQzIHNjYWxlIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yIHlvdSB3YW50IHRvIGV4dHJhIG9wdGlvbnMuICovXG5cdGV4cG9ydCBsZXQgeVNjYWxlID0gZGVmYXVsdFNjYWxlcy55O1xuXHQvKiogQHR5cGUge0Z1bmN0aW9ufSBbelNjYWxlPWQzLnNjYWxlTGluZWFyXSBUaGUgRDMgc2NhbGUgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIHgtZGltZW5zaW9uLiBQYXNzIGluIGFuIGluc3RhbnRpYXRlZCBEMyBzY2FsZSBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBvciB5b3Ugd2FudCB0byBleHRyYSBvcHRpb25zLiAqL1xuXHRleHBvcnQgbGV0IHpTY2FsZSA9IGRlZmF1bHRTY2FsZXMuejtcblx0LyoqIEB0eXBlIHtGdW5jdGlvbn0gW3JTY2FsZT1kMy5zY2FsZVNxcnRdIFRoZSBEMyBzY2FsZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgeC1kaW1lbnNpb24uIFBhc3MgaW4gYW4gaW5zdGFudGlhdGVkIEQzIHNjYWxlIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yIHlvdSB3YW50IHRvIGV4dHJhIG9wdGlvbnMuICovXG5cdGV4cG9ydCBsZXQgclNjYWxlID0gZGVmYXVsdFNjYWxlcy5yO1xuXHQvKiogQHR5cGUge1ttaW46IE51bWJlciwgbWF4OiBOdW1iZXJdfEZ1bmN0aW9ufFN0cmluZ1tdfE51bWJlcltdfSBbeFJhbmdlXSBPdmVycmlkZSB0aGUgZGVmYXVsdCB4IHJhbmdlIG9mIGBbMCwgd2lkdGhdYCBieSBzZXR0aW5nIGFuIGFycmF5IG9yIGZ1bmN0aW9uIHdpdGggYXJndW1lbnQgYCh7IHdpZHRoLCBoZWlnaHR9KWAgdGhhdCByZXR1cm5zIGFuIGFycmF5LiBTZXR0aW5nIHRoaXMgcHJvcCBvdmVycmlkZXMgYHhSZXZlcnNlYC4gVGhpcyBjYW4gYWxzbyBiZSBhIGxpc3Qgb2YgbnVtYmVycyBvciBzdHJpbmdzIGZvciBzY2FsZXMgd2l0aCBkaXNjcmV0ZSByYW5nZXMgbGlrZSBbc2NhbGVUaHJlc2hob2xkXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjdGhyZXNob2xkLXNjYWxlcykgb3IgW3NjYWxlUXVhbnRpemVdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNxdWFudGl6ZS1zY2FsZXMpLiAqL1xuXHRleHBvcnQgbGV0IHhSYW5nZSA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtbbWluOiBOdW1iZXIsIG1heDogTnVtYmVyXXxGdW5jdGlvbnxTdHJpbmdbXXxOdW1iZXJbXX0gW3hSYW5nZV0gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgeSByYW5nZSBvZiBgWzAsIGhlaWdodF1gIGJ5IHNldHRpbmcgYW4gYXJyYXkgb3IgZnVuY3Rpb24gd2l0aCBhcmd1bWVudCBgKHsgd2lkdGgsIGhlaWdodH0pYCB0aGF0IHJldHVybnMgYW4gYXJyYXkuIFNldHRpbmcgdGhpcyBwcm9wIG92ZXJyaWRlcyBgeVJldmVyc2VgLiBUaGlzIGNhbiBhbHNvIGJlIGEgbGlzdCBvZiBudW1iZXJzIG9yIHN0cmluZ3MgZm9yIHNjYWxlcyB3aXRoIGRpc2NyZXRlIHJhbmdlcyBsaWtlIFtzY2FsZVRocmVzaGhvbGRdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSN0aHJlc2hvbGQtc2NhbGVzKSBvciBbc2NhbGVRdWFudGl6ZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3F1YW50aXplLXNjYWxlcykuICovXG5cdGV4cG9ydCBsZXQgeVJhbmdlID0gdW5kZWZpbmVkO1xuXHQvKiogQHR5cGUge1ttaW46IE51bWJlciwgbWF4OiBOdW1iZXJdfEZ1bmN0aW9ufFN0cmluZ1tdfE51bWJlcltdfSBbelJhbmdlXSBPdmVycmlkZSB0aGUgZGVmYXVsdCB6IHJhbmdlIG9mIGBbMCwgd2lkdGhdYCBieSBzZXR0aW5nIGFuIGFycmF5IG9yIGZ1bmN0aW9uIHdpdGggYXJndW1lbnQgYCh7IHdpZHRoLCBoZWlnaHR9KWAgdGhhdCByZXR1cm5zIGFuIGFycmF5LiBTZXR0aW5nIHRoaXMgcHJvcCBvdmVycmlkZXMgYHpSZXZlcnNlYC4gVGhpcyBjYW4gYWxzbyBiZSBhIGxpc3Qgb2YgbnVtYmVycyBvciBzdHJpbmdzIGZvciBzY2FsZXMgd2l0aCBkaXNjcmV0ZSByYW5nZXMgbGlrZSBbc2NhbGVUaHJlc2hob2xkXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjdGhyZXNob2xkLXNjYWxlcykgb3IgW3NjYWxlUXVhbnRpemVdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNxdWFudGl6ZS1zY2FsZXMpLiAqL1xuXHRleHBvcnQgbGV0IHpSYW5nZSA9IHVuZGVmaW5lZDtcblx0LyoqIEB0eXBlIHtbbWluOiBOdW1iZXIsIG1heDogTnVtYmVyXXxGdW5jdGlvbnxTdHJpbmdbXXxOdW1iZXJbXX0gW3JSYW5nZV0gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgciByYW5nZSBvZiBgWzEsIDI1XWAgYnkgc2V0dGluZyBhbiBhcnJheSBvciBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50IGAoeyB3aWR0aCwgaGVpZ2h0fSlgIHRoYXQgcmV0dXJucyBhbiBhcnJheS4gU2V0dGluZyB0aGlzIHByb3Agb3ZlcnJpZGVzIGByUmV2ZXJzZWAuIFRoaXMgY2FuIGFsc28gYmUgYSBsaXN0IG9mIG51bWJlcnMgb3Igc3RyaW5ncyBmb3Igc2NhbGVzIHdpdGggZGlzY3JldGUgcmFuZ2VzIGxpa2UgW3NjYWxlVGhyZXNoaG9sZF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3RocmVzaG9sZC1zY2FsZXMpIG9yIFtzY2FsZVF1YW50aXplXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjcXVhbnRpemUtc2NhbGVzKS4gKi9cblx0ZXhwb3J0IGxldCByUmFuZ2UgPSB1bmRlZmluZWQ7XG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gW3hSZXZlcnNlPWZhbHNlXSBSZXZlcnNlIHRoZSBkZWZhdWx0IHggcmFuZ2UuIEJ5IGRlZmF1bHQgdGhpcyBpcyBgZmFsc2VgIGFuZCB0aGUgcmFuZ2UgaXMgYFswLCB3aWR0aF1gLiBJZ25vcmVkIGlmIHlvdSBzZXQgdGhlIHhSYW5nZSBwcm9wLiAqL1xuXHRleHBvcnQgbGV0IHhSZXZlcnNlID0gZmFsc2U7XG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gW3lSZXZlcnNlPXRydWVdIFJldmVyc2UgdGhlIGRlZmF1bHQgeSByYW5nZS4gQnkgZGVmYXVsdCB0aGlzIGlzIGB0cnVlYCBhbmQgdGhlIHJhbmdlIGlzIGBbaGVpZ2h0LCAwXWAgdW5sZXNzIHVzaW5nIGFuIG9yZGluYWwgc2NhbGUgd2l0aCBhIGAuYmFuZHdpZHRoYCBtZXRob2QgZm9yIGB5U2NhbGVgLiBJZ25vcmVkIGlmIHlvdSBzZXQgdGhlIGB5UmFuZ2VgIHByb3AuICovXG5cdGV4cG9ydCBsZXQgeVJldmVyc2UgPSB1bmRlZmluZWRcblx0LyoqIEB0eXBlIHtCb29sZWFufSBbelJldmVyc2U9ZmFsc2VdIFJldmVyc2UgdGhlIGRlZmF1bHQgeiByYW5nZS4gQnkgZGVmYXVsdCB0aGlzIGlzIGBmYWxzZWAgYW5kIHRoZSByYW5nZSBpcyBgWzAsIHdpZHRoXWAuIElnbm9yZWQgaWYgeW91IHNldCB0aGUgelJhbmdlIHByb3AuICovXG5cdGV4cG9ydCBsZXQgelJldmVyc2UgPSBmYWxzZTtcblx0LyoqIEB0eXBlIHtCb29sZWFufSBbclJldmVyc2U9ZmFsc2VdIFJldmVyc2UgdGhlIGRlZmF1bHQgciByYW5nZS4gQnkgZGVmYXVsdCB0aGlzIGlzIGBmYWxzZWAgYW5kIHRoZSByYW5nZSBpcyBgWzEsIDI1XWAuIElnbm9yZWQgaWYgeW91IHNldCB0aGUgclJhbmdlIHByb3AuICovXG5cdGV4cG9ydCBsZXQgclJldmVyc2UgPSBmYWxzZTtcblx0LyoqIEB0eXBlIHt7dG9wPzogTnVtYmVyLCByaWdodD86IE51bWJlciwgYm90dG9tPzogTnVtYmVyLCBsZWZ0PzogTnVtYmVyfX0gW3BhZGRpbmc9e31dIFRoZSBhbW91bnQgb2YgcGFkZGluZyB0byBwdXQgYXJvdW5kIHlvdXIgY2hhcnQuIEl0IG9wZXJhdGVzIGxpa2UgQ1NTIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IHdoZXJlIHZhbHVlcyBhcmUgc3VidHJhY3RlZCBmcm9tIHRoZSBwYXJlbnQgY29udGFpbmVyJ3Mgd2lkdGggYW5kIGhlaWdodCwgdGhlIHNhbWUgYXMgYSBbRDMgbWFyZ2luIGNvbnZlbnRpb25dKGh0dHBzOi8vYmwub2Nrcy5vcmcvbWJvc3RvY2svMzAxOTU2MykuICovXG5cdGV4cG9ydCBsZXQgcGFkZGluZyA9IHt9O1xuXHQvKiogQHR5cGUge3sgeD86IFttaW46IE51bWJlciwgbWF4OiBOdW1iZXJdLCB5PzogW21pbjogTnVtYmVyLCBtYXg6IE51bWJlcl0sIHI/OiBbbWluOiBOdW1iZXIsIG1heDogTnVtYmVyXSwgej86IFttaW46IE51bWJlciwgbWF4OiBOdW1iZXJdIH19IFtleHRlbnRzXSBNYW51YWxseSBzZXQgdGhlIGV4dGVudHMgb2YgdGhlIHgsIHkgb3IgciBzY2FsZSBhcyBhIHR3by1kaW1lbnNpb25hbCBhcnJheSBvZiB0aGUgbWluIGFuZCBtYXggeW91IHdhbnQuIFNldHRpbmcgdmFsdWVzIGhlcmUgd2lsbCBza2lwIGFueSBkeW5hbWljIGV4dGVudCBjYWxjdWxhdGlvbiBvZiB0aGUgZGF0YSBmb3IgdGhhdCBkaW1lbnNpb24uICovXG5cdGV4cG9ydCBsZXQgZXh0ZW50cyA9IHt9O1xuXG5cdC8qKiBAdHlwZSB7QXJyYXl9IFtmbGF0RGF0YT1kYXRhXSBBIGZsYXQgdmVyc2lvbiBvZiBkYXRhLiAqL1xuXHRleHBvcnQgbGV0IGZsYXREYXRhID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7T2JqZWN0fSBjdXN0b20gQW55IGV4dHJhIGNvbmZpZ3VyYXRpb24gdmFsdWVzIHlvdSB3YW50IGF2YWlsYWJsZSBvbiB0aGUgTGF5ZXJDYWtlIGNvbnRleHQuIFRoaXMgY291bGQgYmUgdXNlZnVsIGZvciBjb2xvciBsb29rdXBzIG9yIGFkZGl0aW9uYWwgY29uc3RhbnRzLiAqL1xuXHRleHBvcnQgbGV0IGN1c3RvbSA9IHt9O1xuXG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gZGVidWcgRW5hYmxlIGRlYnVnIHByaW50aW5nIHRvIHRoZSBjb25zb2xlLiBVc2VmdWwgdG8gaW5zcGVjdCB5b3VyIHNjYWxlcyBhbmQgZGltZW5zaW9ucy4gKi9cblx0ZXhwb3J0IGxldCBkZWJ1ZyA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBNYWtlIHRoaXMgcmVhY3RpdmVcblx0ICovXG5cdCQ6IHlSZXZlcnNlVmFsdWUgPSB0eXBlb2YgeVJldmVyc2UgPT09ICd1bmRlZmluZWQnXG5cdFx0PyB0eXBlb2YgeVNjYWxlLmJhbmR3aWR0aCA9PT0gJ2Z1bmN0aW9uJyA/IGZhbHNlIDogdHJ1ZVxuXHRcdDogeVJldmVyc2U7XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogS2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWRcblx0ICogVGhpcyBpcyB1c2VkIHRvIGVtaXQgd2FybmluZ3Mgb25jZSB3ZSBoYXZlIG1lYXN1cmVkXG5cdCAqIHRoZSBjb250YWluZXIgb2JqZWN0IGFuZCBpdCBkb2Vzbid0IGhhdmUgcHJvcGVyIGRpbWVuc2lvbnNcblx0ICovXG5cdGxldCBpc01vdW50ZWQgPSBmYWxzZTtcblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0aXNNb3VudGVkID0gdHJ1ZTtcblx0fSk7XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogUHJlc2VydmUgYSBjb3B5IG9mIG91ciBwYXNzZWQgaW4gc2V0dGluZ3MgYmVmb3JlIHdlIG1vZGlmeSB0aGVtXG5cdCAqIFJldHVybiB0aGlzIHRvIHRoZSB1c2VyJ3MgY29udGV4dCBzbyB0aGV5IGNhbiByZWZlcmVuY2UgdGhpbmdzIGlmIG5lZWQgYmVcblx0ICogQWRkIHRoZSBhY3RpdmUga2V5cyBzaW5jZSB0aG9zZSBhcmVuJ3Qgb24gb3VyIHNldHRpbmdzIG9iamVjdC5cblx0ICogVGhpcyBpcyBtb3N0bHkgYW4gZXNjYXBlLWhhdGNoXG5cdCAqL1xuXHRjb25zdCBjb25maWcgPSB7fTtcblx0JDogaWYgKHgpIGNvbmZpZy54ID0geDtcblx0JDogaWYgKHkpIGNvbmZpZy55ID0geTtcblx0JDogaWYgKHopIGNvbmZpZy56ID0gejtcblx0JDogaWYgKHIpIGNvbmZpZy5yID0gcjtcblx0JDogaWYgKHhEb21haW4pIGNvbmZpZy54RG9tYWluID0geERvbWFpbjtcblx0JDogaWYgKHlEb21haW4pIGNvbmZpZy55RG9tYWluID0geURvbWFpbjtcblx0JDogaWYgKHpEb21haW4pIGNvbmZpZy56RG9tYWluID0gekRvbWFpbjtcblx0JDogaWYgKHJEb21haW4pIGNvbmZpZy5yRG9tYWluID0gckRvbWFpbjtcblx0JDogaWYgKHhSYW5nZSkgY29uZmlnLnhSYW5nZSA9IHhSYW5nZTtcblx0JDogaWYgKHlSYW5nZSkgY29uZmlnLnlSYW5nZSA9IHlSYW5nZTtcblx0JDogaWYgKHpSYW5nZSkgY29uZmlnLnpSYW5nZSA9IHpSYW5nZTtcblx0JDogaWYgKHJSYW5nZSkgY29uZmlnLnJSYW5nZSA9IHJSYW5nZTtcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBNYWtlIHN0b3JlIHZlcnNpb25zIG9mIGVhY2ggcGFyYW1ldGVyXG5cdCAqIFByZWZpeCB0aGVzZSB3aXRoIGBfYCB0byBrZWVwIHRoaW5ncyBvcmdhbml6ZWRcblx0ICovXG5cdGNvbnN0IF9wZXJjZW50UmFuZ2UgPSB3cml0YWJsZShwZXJjZW50UmFuZ2UpO1xuXHRjb25zdCBfY29udGFpbmVyV2lkdGggPSB3cml0YWJsZShjb250YWluZXJXaWR0aCk7XG5cdGNvbnN0IF9jb250YWluZXJIZWlnaHQgPSB3cml0YWJsZShjb250YWluZXJIZWlnaHQpO1xuXHRjb25zdCBfZXh0ZW50cyA9IHdyaXRhYmxlKGZpbHRlck9iamVjdChleHRlbnRzKSk7XG5cdGNvbnN0IF9kYXRhID0gd3JpdGFibGUoZGF0YSk7XG5cdGNvbnN0IF9mbGF0RGF0YSA9IHdyaXRhYmxlKGZsYXREYXRhIHx8IGRhdGEpO1xuXHRjb25zdCBfcGFkZGluZyA9IHdyaXRhYmxlKHBhZGRpbmcpO1xuXHRjb25zdCBfeCA9IHdyaXRhYmxlKG1ha2VBY2Nlc3Nvcih4KSk7XG5cdGNvbnN0IF95ID0gd3JpdGFibGUobWFrZUFjY2Vzc29yKHkpKTtcblx0Y29uc3QgX3ogPSB3cml0YWJsZShtYWtlQWNjZXNzb3IoeikpO1xuXHRjb25zdCBfciA9IHdyaXRhYmxlKG1ha2VBY2Nlc3NvcihyKSk7XG5cdGNvbnN0IF94RG9tYWluID0gd3JpdGFibGUoeERvbWFpbik7XG5cdGNvbnN0IF95RG9tYWluID0gd3JpdGFibGUoeURvbWFpbik7XG5cdGNvbnN0IF96RG9tYWluID0gd3JpdGFibGUoekRvbWFpbik7XG5cdGNvbnN0IF9yRG9tYWluID0gd3JpdGFibGUockRvbWFpbik7XG5cdGNvbnN0IF94TmljZSA9IHdyaXRhYmxlKHhOaWNlKTtcblx0Y29uc3QgX3lOaWNlID0gd3JpdGFibGUoeU5pY2UpO1xuXHRjb25zdCBfek5pY2UgPSB3cml0YWJsZSh6TmljZSk7XG5cdGNvbnN0IF9yTmljZSA9IHdyaXRhYmxlKHJOaWNlKTtcblx0Y29uc3QgX3hSZXZlcnNlID0gd3JpdGFibGUoeFJldmVyc2UpO1xuXHRjb25zdCBfeVJldmVyc2UgPSB3cml0YWJsZSh5UmV2ZXJzZVZhbHVlKTtcblx0Y29uc3QgX3pSZXZlcnNlID0gd3JpdGFibGUoelJldmVyc2UpO1xuXHRjb25zdCBfclJldmVyc2UgPSB3cml0YWJsZShyUmV2ZXJzZSk7XG5cdGNvbnN0IF94UGFkZGluZyA9IHdyaXRhYmxlKHhQYWRkaW5nKTtcblx0Y29uc3QgX3lQYWRkaW5nID0gd3JpdGFibGUoeVBhZGRpbmcpO1xuXHRjb25zdCBfelBhZGRpbmcgPSB3cml0YWJsZSh6UGFkZGluZyk7XG5cdGNvbnN0IF9yUGFkZGluZyA9IHdyaXRhYmxlKHJQYWRkaW5nKTtcblx0Y29uc3QgX3hSYW5nZSA9IHdyaXRhYmxlKHhSYW5nZSk7XG5cdGNvbnN0IF95UmFuZ2UgPSB3cml0YWJsZSh5UmFuZ2UpO1xuXHRjb25zdCBfelJhbmdlID0gd3JpdGFibGUoelJhbmdlKTtcblx0Y29uc3QgX3JSYW5nZSA9IHdyaXRhYmxlKHJSYW5nZSk7XG5cdGNvbnN0IF94U2NhbGUgPSB3cml0YWJsZSh4U2NhbGUpO1xuXHRjb25zdCBfeVNjYWxlID0gd3JpdGFibGUoeVNjYWxlKTtcblx0Y29uc3QgX3pTY2FsZSA9IHdyaXRhYmxlKHpTY2FsZSk7XG5cdGNvbnN0IF9yU2NhbGUgPSB3cml0YWJsZShyU2NhbGUpO1xuXHRjb25zdCBfY29uZmlnID0gd3JpdGFibGUoY29uZmlnKTtcblx0Y29uc3QgX2N1c3RvbSA9IHdyaXRhYmxlKGN1c3RvbSk7XG5cblx0JDogJF9wZXJjZW50UmFuZ2UgPSBwZXJjZW50UmFuZ2U7XG5cdCQ6ICRfY29udGFpbmVyV2lkdGggPSBjb250YWluZXJXaWR0aDtcblx0JDogJF9jb250YWluZXJIZWlnaHQgPSBjb250YWluZXJIZWlnaHQ7XG5cdCQ6ICRfZXh0ZW50cyA9IGZpbHRlck9iamVjdChleHRlbnRzKTtcblx0JDogJF9kYXRhID0gZGF0YTtcblx0JDogJF9mbGF0RGF0YSA9IGZsYXREYXRhIHx8IGRhdGE7XG5cdCQ6ICRfcGFkZGluZyA9IHBhZGRpbmc7XG5cdCQ6ICRfeCA9IG1ha2VBY2Nlc3Nvcih4KTtcblx0JDogJF95ID0gbWFrZUFjY2Vzc29yKHkpO1xuXHQkOiAkX3ogPSBtYWtlQWNjZXNzb3Ioeik7XG5cdCQ6ICRfciA9IG1ha2VBY2Nlc3NvcihyKTtcblx0JDogJF94RG9tYWluID0geERvbWFpbjtcblx0JDogJF95RG9tYWluID0geURvbWFpbjtcblx0JDogJF96RG9tYWluID0gekRvbWFpbjtcblx0JDogJF9yRG9tYWluID0gckRvbWFpbjtcblx0JDogJF94TmljZSA9IHhOaWNlO1xuXHQkOiAkX3lOaWNlID0geU5pY2U7XG5cdCQ6ICRfek5pY2UgPSB6TmljZTtcblx0JDogJF9yTmljZSA9IHJOaWNlO1xuXHQkOiAkX3hSZXZlcnNlID0geFJldmVyc2U7XG5cdCQ6ICRfeVJldmVyc2UgPSB5UmV2ZXJzZVZhbHVlO1xuXHQkOiAkX3pSZXZlcnNlID0gelJldmVyc2U7XG5cdCQ6ICRfclJldmVyc2UgPSByUmV2ZXJzZTtcblx0JDogJF94UGFkZGluZyA9IHhQYWRkaW5nO1xuXHQkOiAkX3lQYWRkaW5nID0geVBhZGRpbmc7XG5cdCQ6ICRfelBhZGRpbmcgPSB6UGFkZGluZztcblx0JDogJF9yUGFkZGluZyA9IHJQYWRkaW5nO1xuXHQkOiAkX3hSYW5nZSA9IHhSYW5nZTtcblx0JDogJF95UmFuZ2UgPSB5UmFuZ2U7XG5cdCQ6ICRfelJhbmdlID0gelJhbmdlO1xuXHQkOiAkX3JSYW5nZSA9IHJSYW5nZTtcblx0JDogJF94U2NhbGUgPSB4U2NhbGU7XG5cdCQ6ICRfeVNjYWxlID0geVNjYWxlO1xuXHQkOiAkX3pTY2FsZSA9IHpTY2FsZTtcblx0JDogJF9yU2NhbGUgPSByU2NhbGU7XG5cdCQ6ICRfY3VzdG9tID0gY3VzdG9tO1xuXHQkOiAkX2NvbmZpZyA9IGNvbmZpZztcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBDcmVhdGUgZGVyaXZlZCB2YWx1ZXNcblx0ICogU3VmZml4IHRoZXNlIHdpdGggYF9kYFxuXHQgKi9cblx0Y29uc3QgYWN0aXZlR2V0dGVyc19kID0gZGVyaXZlZChbX3gsIF95LCBfeiwgX3JdLCAoWyR4LCAkeSwgJHosICRyXSkgPT4ge1xuXHRcdGNvbnN0IG9iaiA9IHt9O1xuXHRcdGlmICgkeCkge1xuXHRcdFx0b2JqLnggPSAkeDtcblx0XHR9XG5cdFx0aWYgKCR5KSB7XG5cdFx0XHRvYmoueSA9ICR5O1xuXHRcdH1cblx0XHRpZiAoJHopIHtcblx0XHRcdG9iai56ID0gJHo7XG5cdFx0fVxuXHRcdGlmICgkcikge1xuXHRcdFx0b2JqLnIgPSAkcjtcblx0XHR9XG5cdFx0cmV0dXJuIG9iajtcblx0fSk7XG5cblx0Y29uc3QgcGFkZGluZ19kID0gZGVyaXZlZChbX3BhZGRpbmcsIF9jb250YWluZXJXaWR0aCwgX2NvbnRhaW5lckhlaWdodF0sIChbJHBhZGRpbmddKSA9PiB7XG5cdFx0Y29uc3QgZGVmYXVsdFBhZGRpbmcgPSB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCB9O1xuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRQYWRkaW5nLCAkcGFkZGluZyk7XG5cdH0pO1xuXG5cdGNvbnN0IGJveF9kID0gZGVyaXZlZChcblx0XHRbX2NvbnRhaW5lcldpZHRoLCBfY29udGFpbmVySGVpZ2h0LCBwYWRkaW5nX2RdLFxuXHRcdChbJGNvbnRhaW5lcldpZHRoLCAkY29udGFpbmVySGVpZ2h0LCAkcGFkZGluZ10pID0+IHtcblx0XHRcdGNvbnN0IGIgPSB7fTtcblx0XHRcdGIudG9wID0gJHBhZGRpbmcudG9wO1xuXHRcdFx0Yi5yaWdodCA9ICRjb250YWluZXJXaWR0aCAtICRwYWRkaW5nLnJpZ2h0O1xuXHRcdFx0Yi5ib3R0b20gPSAkY29udGFpbmVySGVpZ2h0IC0gJHBhZGRpbmcuYm90dG9tO1xuXHRcdFx0Yi5sZWZ0ID0gJHBhZGRpbmcubGVmdDtcblx0XHRcdGIud2lkdGggPSBiLnJpZ2h0IC0gYi5sZWZ0O1xuXHRcdFx0Yi5oZWlnaHQgPSBiLmJvdHRvbSAtIGIudG9wO1xuXHRcdFx0aWYgKGIud2lkdGggPD0gMCAmJiBpc01vdW50ZWQgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdCdbTGF5ZXJDYWtlXSBUYXJnZXQgZGl2IGhhcyB6ZXJvIG9yIG5lZ2F0aXZlIHdpZHRoLiBEaWQgeW91IGZvcmdldCB0byBzZXQgYW4gZXhwbGljaXQgd2lkdGggaW4gQ1NTIG9uIHRoZSBjb250YWluZXI/J1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGIuaGVpZ2h0IDw9IDAgJiYgaXNNb3VudGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHQnW0xheWVyQ2FrZV0gVGFyZ2V0IGRpdiBoYXMgemVybyBvciBuZWdhdGl2ZSBoZWlnaHQuIERpZCB5b3UgZm9yZ2V0IHRvIHNldCBhbiBleHBsaWNpdCBoZWlnaHQgaW4gQ1NTIG9uIHRoZSBjb250YWluZXI/J1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGI7XG5cdFx0fVxuXHQpO1xuXG5cdGNvbnN0IHdpZHRoX2QgPSBkZXJpdmVkKFtib3hfZF0sIChbJGJveF0pID0+IHtcblx0XHRyZXR1cm4gJGJveC53aWR0aDtcblx0fSk7XG5cblx0Y29uc3QgaGVpZ2h0X2QgPSBkZXJpdmVkKFtib3hfZF0sIChbJGJveF0pID0+IHtcblx0XHRyZXR1cm4gJGJveC5oZWlnaHQ7XG5cdH0pO1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIENhbGN1bGF0ZSBleHRlbnRzIGJ5IHRha2luZyB0aGUgZXh0ZW50IG9mIHRoZSBkYXRhXG5cdCAqIGFuZCBmaWxsaW5nIHRoYXQgaW4gd2l0aCBhbnl0aGluZyBzZXQgYnkgdGhlIHVzZXJcblx0ICogTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20gYW4gXCJleHRlbnRcIiBwYXNzZWRcblx0ICogaW4gYXMgYSBkb21haW4sIHdoaWNoIGNhbiBiZSBhIHBhcnRpYWwgZG9tYWluXG5cdCAqL1xuXHRjb25zdCBleHRlbnRzX2QgPSBkZXJpdmVkKFxuXHRcdFtfZmxhdERhdGEsIGFjdGl2ZUdldHRlcnNfZCwgX2V4dGVudHMsIF94U2NhbGUsIF95U2NhbGUsIF9yU2NhbGUsIF96U2NhbGVdLFxuXHRcdChbJGZsYXREYXRhLCAkYWN0aXZlR2V0dGVycywgJGV4dGVudHMsICRfeFNjYWxlLCAkX3lTY2FsZSwgJF9yU2NhbGUsICRfelNjYWxlXSkgPT4ge1xuXHRcdFx0Y29uc3Qgc2NhbGVMb29rdXAgPSB7IHg6ICRfeFNjYWxlLCB5OiAkX3lTY2FsZSwgcjogJF9yU2NhbGUsIHo6ICRfelNjYWxlIH07XG5cdFx0XHRjb25zdCBnZXR0ZXJzID0gZmlsdGVyT2JqZWN0KCRhY3RpdmVHZXR0ZXJzLCAkZXh0ZW50cyk7XG5cdFx0XHRjb25zdCBhY3RpdmVTY2FsZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoZ2V0dGVycykubWFwKChrKSA9PiBbaywgc2NhbGVMb29rdXBba11dKSk7XG5cblx0XHRcdGlmIChPYmplY3Qua2V5cyhnZXR0ZXJzKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnN0IGNhbGN1bGF0ZWRFeHRlbnRzID0gY2FsY1NjYWxlRXh0ZW50cygkZmxhdERhdGEsIGdldHRlcnMsIGFjdGl2ZVNjYWxlcyk7XG5cdFx0XHRcdHJldHVybiB7IC4uLmNhbGN1bGF0ZWRFeHRlbnRzLCAuLi4kZXh0ZW50cyB9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHt9O1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcblxuXHRjb25zdCB4RG9tYWluX2QgPSBkZXJpdmVkKFtleHRlbnRzX2QsIF94RG9tYWluXSwgY2FsY0RvbWFpbigneCcpKTtcblx0Y29uc3QgeURvbWFpbl9kID0gZGVyaXZlZChbZXh0ZW50c19kLCBfeURvbWFpbl0sIGNhbGNEb21haW4oJ3knKSk7XG5cdGNvbnN0IHpEb21haW5fZCA9IGRlcml2ZWQoW2V4dGVudHNfZCwgX3pEb21haW5dLCBjYWxjRG9tYWluKCd6JykpO1xuXHRjb25zdCByRG9tYWluX2QgPSBkZXJpdmVkKFtleHRlbnRzX2QsIF9yRG9tYWluXSwgY2FsY0RvbWFpbigncicpKTtcblxuXHRjb25zdCB4U2NhbGVfZCA9IGRlcml2ZWQoXG5cdFx0W1xuXHRcdFx0X3hTY2FsZSxcblx0XHRcdGV4dGVudHNfZCxcblx0XHRcdHhEb21haW5fZCxcblx0XHRcdF94UGFkZGluZyxcblx0XHRcdF94TmljZSxcblx0XHRcdF94UmV2ZXJzZSxcblx0XHRcdHdpZHRoX2QsXG5cdFx0XHRoZWlnaHRfZCxcblx0XHRcdF94UmFuZ2UsXG5cdFx0XHRfcGVyY2VudFJhbmdlXG5cdFx0XSxcblx0XHRjcmVhdGVTY2FsZSgneCcpXG5cdCk7XG5cdGNvbnN0IHhHZXRfZCA9IGRlcml2ZWQoW194LCB4U2NhbGVfZF0sIGNyZWF0ZUdldHRlcik7XG5cblx0Y29uc3QgeVNjYWxlX2QgPSBkZXJpdmVkKFxuXHRcdFtcblx0XHRcdF95U2NhbGUsXG5cdFx0XHRleHRlbnRzX2QsXG5cdFx0XHR5RG9tYWluX2QsXG5cdFx0XHRfeVBhZGRpbmcsXG5cdFx0XHRfeU5pY2UsXG5cdFx0XHRfeVJldmVyc2UsXG5cdFx0XHR3aWR0aF9kLFxuXHRcdFx0aGVpZ2h0X2QsXG5cdFx0XHRfeVJhbmdlLFxuXHRcdFx0X3BlcmNlbnRSYW5nZVxuXHRcdF0sXG5cdFx0Y3JlYXRlU2NhbGUoJ3knKVxuXHQpO1xuXHRjb25zdCB5R2V0X2QgPSBkZXJpdmVkKFtfeSwgeVNjYWxlX2RdLCBjcmVhdGVHZXR0ZXIpO1xuXG5cdGNvbnN0IHpTY2FsZV9kID0gZGVyaXZlZChcblx0XHRbXG5cdFx0XHRfelNjYWxlLFxuXHRcdFx0ZXh0ZW50c19kLFxuXHRcdFx0ekRvbWFpbl9kLFxuXHRcdFx0X3pQYWRkaW5nLFxuXHRcdFx0X3pOaWNlLFxuXHRcdFx0X3pSZXZlcnNlLFxuXHRcdFx0d2lkdGhfZCxcblx0XHRcdGhlaWdodF9kLFxuXHRcdFx0X3pSYW5nZSxcblx0XHRcdF9wZXJjZW50UmFuZ2Vcblx0XHRdLFxuXHRcdGNyZWF0ZVNjYWxlKCd6Jylcblx0KTtcblx0Y29uc3QgekdldF9kID0gZGVyaXZlZChbX3osIHpTY2FsZV9kXSwgY3JlYXRlR2V0dGVyKTtcblxuXHRjb25zdCByU2NhbGVfZCA9IGRlcml2ZWQoXG5cdFx0W1xuXHRcdFx0X3JTY2FsZSxcblx0XHRcdGV4dGVudHNfZCxcblx0XHRcdHJEb21haW5fZCxcblx0XHRcdF9yUGFkZGluZyxcblx0XHRcdF9yTmljZSxcblx0XHRcdF9yUmV2ZXJzZSxcblx0XHRcdHdpZHRoX2QsXG5cdFx0XHRoZWlnaHRfZCxcblx0XHRcdF9yUmFuZ2UsXG5cdFx0XHRfcGVyY2VudFJhbmdlXG5cdFx0XSxcblx0XHRjcmVhdGVTY2FsZSgncicpXG5cdCk7XG5cdGNvbnN0IHJHZXRfZCA9IGRlcml2ZWQoW19yLCByU2NhbGVfZF0sIGNyZWF0ZUdldHRlcik7XG5cblx0Y29uc3QgeFJhbmdlX2QgPSBkZXJpdmVkKFt4U2NhbGVfZF0sIGdldFJhbmdlKTtcblx0Y29uc3QgeVJhbmdlX2QgPSBkZXJpdmVkKFt5U2NhbGVfZF0sIGdldFJhbmdlKTtcblx0Y29uc3QgelJhbmdlX2QgPSBkZXJpdmVkKFt6U2NhbGVfZF0sIGdldFJhbmdlKTtcblx0Y29uc3QgclJhbmdlX2QgPSBkZXJpdmVkKFtyU2NhbGVfZF0sIGdldFJhbmdlKTtcblxuXHRjb25zdCBhc3BlY3RSYXRpb19kID0gZGVyaXZlZChbd2lkdGhfZCwgaGVpZ2h0X2RdLCAoWyR3aWR0aCwgJGhlaWdodF0pID0+IHtcblx0XHRyZXR1cm4gJHdpZHRoIC8gJGhlaWdodDtcblx0fSk7XG5cblx0JDogY29udGV4dCA9IHtcblx0XHRhY3RpdmVHZXR0ZXJzOiBhY3RpdmVHZXR0ZXJzX2QsXG5cdFx0d2lkdGg6IHdpZHRoX2QsXG5cdFx0aGVpZ2h0OiBoZWlnaHRfZCxcblx0XHRwZXJjZW50UmFuZ2U6IF9wZXJjZW50UmFuZ2UsXG5cdFx0YXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvX2QsXG5cdFx0Y29udGFpbmVyV2lkdGg6IF9jb250YWluZXJXaWR0aCxcblx0XHRjb250YWluZXJIZWlnaHQ6IF9jb250YWluZXJIZWlnaHQsXG5cdFx0eDogX3gsXG5cdFx0eTogX3ksXG5cdFx0ejogX3osXG5cdFx0cjogX3IsXG5cdFx0Y3VzdG9tOiBfY3VzdG9tLFxuXHRcdGRhdGE6IF9kYXRhLFxuXHRcdHhOaWNlOiBfeE5pY2UsXG5cdFx0eU5pY2U6IF95TmljZSxcblx0XHR6TmljZTogX3pOaWNlLFxuXHRcdHJOaWNlOiBfck5pY2UsXG5cdFx0eFJldmVyc2U6IF94UmV2ZXJzZSxcblx0XHR5UmV2ZXJzZTogX3lSZXZlcnNlLFxuXHRcdHpSZXZlcnNlOiBfelJldmVyc2UsXG5cdFx0clJldmVyc2U6IF9yUmV2ZXJzZSxcblx0XHR4UGFkZGluZzogX3hQYWRkaW5nLFxuXHRcdHlQYWRkaW5nOiBfeVBhZGRpbmcsXG5cdFx0elBhZGRpbmc6IF96UGFkZGluZyxcblx0XHRyUGFkZGluZzogX3JQYWRkaW5nLFxuXHRcdHBhZGRpbmc6IHBhZGRpbmdfZCxcblx0XHRmbGF0RGF0YTogX2ZsYXREYXRhLFxuXHRcdGV4dGVudHM6IGV4dGVudHNfZCxcblx0XHR4RG9tYWluOiB4RG9tYWluX2QsXG5cdFx0eURvbWFpbjogeURvbWFpbl9kLFxuXHRcdHpEb21haW46IHpEb21haW5fZCxcblx0XHRyRG9tYWluOiByRG9tYWluX2QsXG5cdFx0eFJhbmdlOiB4UmFuZ2VfZCxcblx0XHR5UmFuZ2U6IHlSYW5nZV9kLFxuXHRcdHpSYW5nZTogelJhbmdlX2QsXG5cdFx0clJhbmdlOiByUmFuZ2VfZCxcblx0XHRjb25maWc6IF9jb25maWcsXG5cdFx0eFNjYWxlOiB4U2NhbGVfZCxcblx0XHR4R2V0OiB4R2V0X2QsXG5cdFx0eVNjYWxlOiB5U2NhbGVfZCxcblx0XHR5R2V0OiB5R2V0X2QsXG5cdFx0elNjYWxlOiB6U2NhbGVfZCxcblx0XHR6R2V0OiB6R2V0X2QsXG5cdFx0clNjYWxlOiByU2NhbGVfZCxcblx0XHRyR2V0OiByR2V0X2Rcblx0fTtcblxuXHQkOiBzZXRDb250ZXh0KCdMYXllckNha2UnLCBjb250ZXh0KTtcblxuXHQkOiBpZiAoJGJveF9kICYmIGRlYnVnID09PSB0cnVlICYmIChzc3IgPT09IHRydWUgfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpKSB7XG5cdFx0Ly8gQ2FsbCB0aGlzIGFzIGEgZGVib3VuY2Ugc28gdGhhdCBpdCBkb2Vzbid0IGdldCBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYXMgdGhlc2UgdmFycyBnZXQgZmlsbGVkIGluXG5cdFx0cHJpbnREZWJ1Z19kZWJvdW5jZWQoe1xuXHRcdFx0Ym91bmRpbmdCb3g6ICRib3hfZCxcblx0XHRcdGFjdGl2ZUdldHRlcnM6ICRhY3RpdmVHZXR0ZXJzX2QsXG5cdFx0XHR4OiBjb25maWcueCxcblx0XHRcdHk6IGNvbmZpZy55LFxuXHRcdFx0ejogY29uZmlnLnosXG5cdFx0XHRyOiBjb25maWcucixcblx0XHRcdHhTY2FsZTogJHhTY2FsZV9kLFxuXHRcdFx0eVNjYWxlOiAkeVNjYWxlX2QsXG5cdFx0XHR6U2NhbGU6ICR6U2NhbGVfZCxcblx0XHRcdHJTY2FsZTogJHJTY2FsZV9kLFxuXHRcdH0pO1xuXHR9XG48L3NjcmlwdD5cblxueyNpZiBzc3IgPT09IHRydWUgfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCd9XG5cdDxkaXZcblx0XHRiaW5kOnRoaXM9e2VsZW1lbnR9XG5cdFx0Y2xhc3M9XCJsYXllcmNha2UtY29udGFpbmVyXCJcblx0XHRzdHlsZTpwb3NpdGlvblxuXHRcdHN0eWxlOnRvcD17cG9zaXRpb24gPT09ICdhYnNvbHV0ZScgPyAnMCcgOiBudWxsfVxuXHRcdHN0eWxlOnJpZ2h0PXtwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJyA/ICcwJyA6IG51bGx9XG5cdFx0c3R5bGU6Ym90dG9tPXtwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJyA/ICcwJyA6IG51bGx9XG5cdFx0c3R5bGU6bGVmdD17cG9zaXRpb24gPT09ICdhYnNvbHV0ZScgPyAnMCcgOiBudWxsfVxuXHRcdHN0eWxlOnBvaW50ZXItZXZlbnRzPXtwb2ludGVyRXZlbnRzID09PSBmYWxzZSA/ICdub25lJyA6IG51bGx9XG5cdFx0YmluZDpjbGllbnRXaWR0aD17Y29udGFpbmVyV2lkdGh9XG5cdFx0YmluZDpjbGllbnRIZWlnaHQ9e2NvbnRhaW5lckhlaWdodH1cblx0PlxuXHRcdDxzbG90XG5cdFx0XHR7ZWxlbWVudH1cblx0XHRcdHdpZHRoPXskd2lkdGhfZH1cblx0XHRcdGhlaWdodD17JGhlaWdodF9kfVxuXHRcdFx0YXNwZWN0UmF0aW89eyRhc3BlY3RSYXRpb19kfVxuXHRcdFx0Y29udGFpbmVyV2lkdGg9eyRfY29udGFpbmVyV2lkdGh9XG5cdFx0XHRjb250YWluZXJIZWlnaHQ9eyRfY29udGFpbmVySGVpZ2h0fVxuXHRcdFx0YWN0aXZlR2V0dGVycz17JGFjdGl2ZUdldHRlcnNfZH1cblx0XHRcdHBlcmNlbnRSYW5nZT17JF9wZXJjZW50UmFuZ2V9XG5cdFx0XHR4PXskX3h9XG5cdFx0XHR5PXskX3l9XG5cdFx0XHR6PXskX3p9XG5cdFx0XHRyPXskX3J9XG5cdFx0XHRjdXN0b209eyRfY3VzdG9tfVxuXHRcdFx0ZGF0YT17JF9kYXRhfVxuXHRcdFx0eE5pY2U9eyRfeE5pY2V9XG5cdFx0XHR5TmljZT17JF95TmljZX1cblx0XHRcdHpOaWNlPXskX3pOaWNlfVxuXHRcdFx0ck5pY2U9eyRfck5pY2V9XG5cdFx0XHR4UmV2ZXJzZT17JF94UmV2ZXJzZX1cblx0XHRcdHlSZXZlcnNlPXskX3lSZXZlcnNlfVxuXHRcdFx0elJldmVyc2U9eyRfelJldmVyc2V9XG5cdFx0XHRyUmV2ZXJzZT17JF9yUmV2ZXJzZX1cblx0XHRcdHhQYWRkaW5nPXskX3hQYWRkaW5nfVxuXHRcdFx0eVBhZGRpbmc9eyRfeVBhZGRpbmd9XG5cdFx0XHR6UGFkZGluZz17JF96UGFkZGluZ31cblx0XHRcdHJQYWRkaW5nPXskX3JQYWRkaW5nfVxuXHRcdFx0cGFkZGluZz17JHBhZGRpbmdfZH1cblx0XHRcdGZsYXREYXRhPXskX2ZsYXREYXRhfVxuXHRcdFx0ZXh0ZW50cz17JGV4dGVudHNfZH1cblx0XHRcdHhEb21haW49eyR4RG9tYWluX2R9XG5cdFx0XHR5RG9tYWluPXskeURvbWFpbl9kfVxuXHRcdFx0ekRvbWFpbj17JHpEb21haW5fZH1cblx0XHRcdHJEb21haW49eyRyRG9tYWluX2R9XG5cdFx0XHR4UmFuZ2U9eyR4UmFuZ2VfZH1cblx0XHRcdHlSYW5nZT17JHlSYW5nZV9kfVxuXHRcdFx0elJhbmdlPXskelJhbmdlX2R9XG5cdFx0XHRyUmFuZ2U9eyRyUmFuZ2VfZH1cblx0XHRcdGNvbmZpZz17JF9jb25maWd9XG5cdFx0XHR4U2NhbGU9eyR4U2NhbGVfZH1cblx0XHRcdHhHZXQ9eyR4R2V0X2R9XG5cdFx0XHR5U2NhbGU9eyR5U2NhbGVfZH1cblx0XHRcdHlHZXQ9eyR5R2V0X2R9XG5cdFx0XHR6U2NhbGU9eyR6U2NhbGVfZH1cblx0XHRcdHpHZXQ9eyR6R2V0X2R9XG5cdFx0XHRyU2NhbGU9eyRyU2NhbGVfZH1cblx0XHRcdHJHZXQ9eyRyR2V0X2R9XG5cdFx0Lz5cblx0PC9kaXY+XG57L2lmfVxuXG48c3R5bGU+XG5cdC5sYXllcmNha2UtY29udGFpbmVyLFxuXHQubGF5ZXJjYWtlLWNvbnRhaW5lciA6Z2xvYmFsKCopIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHR9XG5cdC5sYXllcmNha2UtY29udGFpbmVyIHtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBeWhCQyxrQ0FBb0IsQ0FDcEIsa0NBQW9CLENBQVMsQ0FBRyxDQUMvQixVQUFVLENBQUUsVUFDYixDQUNBLGtDQUFxQixDQUNwQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUNUIn0= */");
}
var get_default_slot_changes = (dirty) => ({
  element: dirty[0] & 4,
  width: dirty[1] & 8,
  height: dirty[1] & 16,
  aspectRatio: dirty[1] & 32,
  containerWidth: dirty[1] & 2,
  containerHeight: dirty[1] & 1,
  activeGetters: dirty[0] & 1024,
  percentRange: dirty[1] & 4,
  x: dirty[0] & 268435456,
  y: dirty[0] & 134217728,
  z: dirty[0] & 67108864,
  r: dirty[0] & 33554432,
  custom: dirty[0] & 4096,
  data: dirty[0] & 1073741824,
  xNice: dirty[0] & 16777216,
  yNice: dirty[0] & 8388608,
  zNice: dirty[0] & 4194304,
  rNice: dirty[0] & 2097152,
  xReverse: dirty[0] & 1048576,
  yReverse: dirty[0] & 524288,
  zReverse: dirty[0] & 262144,
  rReverse: dirty[0] & 131072,
  xPadding: dirty[0] & 65536,
  yPadding: dirty[0] & 32768,
  zPadding: dirty[0] & 16384,
  rPadding: dirty[0] & 8192,
  padding: dirty[1] & 64,
  flatData: dirty[0] & 536870912,
  extents: dirty[1] & 128,
  xDomain: dirty[1] & 256,
  yDomain: dirty[1] & 512,
  zDomain: dirty[1] & 1024,
  rDomain: dirty[1] & 2048,
  xRange: dirty[1] & 4096,
  yRange: dirty[1] & 8192,
  zRange: dirty[1] & 16384,
  rRange: dirty[1] & 32768,
  config: dirty[0] & 2048,
  xScale: dirty[0] & 512,
  xGet: dirty[1] & 65536,
  yScale: dirty[0] & 256,
  yGet: dirty[1] & 131072,
  zScale: dirty[0] & 128,
  zGet: dirty[1] & 262144,
  rScale: dirty[0] & 64,
  rGet: dirty[1] & 524288
});
var get_default_slot_context = (ctx) => ({
  element: ctx[2],
  width: ctx[34],
  height: ctx[35],
  aspectRatio: ctx[36],
  containerWidth: ctx[32],
  containerHeight: ctx[31],
  activeGetters: ctx[10],
  percentRange: ctx[33],
  x: ctx[28],
  y: ctx[27],
  z: ctx[26],
  r: ctx[25],
  custom: ctx[12],
  data: ctx[30],
  xNice: ctx[24],
  yNice: ctx[23],
  zNice: ctx[22],
  rNice: ctx[21],
  xReverse: ctx[20],
  yReverse: ctx[19],
  zReverse: ctx[18],
  rReverse: ctx[17],
  xPadding: ctx[16],
  yPadding: ctx[15],
  zPadding: ctx[14],
  rPadding: ctx[13],
  padding: ctx[37],
  flatData: ctx[29],
  extents: ctx[38],
  xDomain: ctx[39],
  yDomain: ctx[40],
  zDomain: ctx[41],
  rDomain: ctx[42],
  xRange: ctx[43],
  yRange: ctx[44],
  zRange: ctx[45],
  rRange: ctx[46],
  config: ctx[11],
  xScale: ctx[9],
  xGet: ctx[47],
  yScale: ctx[8],
  yGet: ctx[48],
  zScale: ctx[7],
  zGet: ctx[49],
  rScale: ctx[6],
  rGet: ctx[50]
});
function create_if_block(ctx) {
  let div;
  let div_resize_listener;
  let current;
  const default_slot_template = ctx[153].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[152], get_default_slot_context);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "layercake-container svelte-vhzpsp");
      add_render_callback(() => ctx[155].call(div));
      set_style(div, "position", ctx[5]);
      set_style(div, "top", ctx[5] === "absolute" ? "0" : null);
      set_style(div, "right", ctx[5] === "absolute" ? "0" : null);
      set_style(div, "bottom", ctx[5] === "absolute" ? "0" : null);
      set_style(div, "left", ctx[5] === "absolute" ? "0" : null);
      set_style(div, "pointer-events", ctx[4] === false ? "none" : null);
      add_location(div, file, 473, 1, 21905);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[154](div);
      div_resize_listener = add_iframe_resize_listener(div, ctx[155].bind(div));
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 2147483588 | dirty[1] & 1048575 | dirty[4] & 268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[152],
            !current ? get_all_dirty_from_scope(ctx2[152]) : get_slot_changes(default_slot_template, ctx2[152], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      }
      if (dirty[0] & 32) {
        set_style(div, "position", ctx2[5]);
      }
      if (dirty[0] & 32) {
        set_style(div, "top", ctx2[5] === "absolute" ? "0" : null);
      }
      if (dirty[0] & 32) {
        set_style(div, "right", ctx2[5] === "absolute" ? "0" : null);
      }
      if (dirty[0] & 32) {
        set_style(div, "bottom", ctx2[5] === "absolute" ? "0" : null);
      }
      if (dirty[0] & 32) {
        set_style(div, "left", ctx2[5] === "absolute" ? "0" : null);
      }
      if (dirty[0] & 16) {
        set_style(div, "pointer-events", ctx2[4] === false ? "none" : null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[154](null);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(473:0) {#if ssr === true || typeof window !== 'undefined'}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (ctx[3] === true || typeof window !== "undefined") && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[3] === true || typeof window !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let yReverseValue;
  let context;
  let $rScale_d;
  let $zScale_d;
  let $yScale_d;
  let $xScale_d;
  let $activeGetters_d;
  let $box_d;
  let $_config;
  let $_custom;
  let $_rScale;
  let $_zScale;
  let $_yScale;
  let $_xScale;
  let $_rRange;
  let $_zRange;
  let $_yRange;
  let $_xRange;
  let $_rPadding;
  let $_zPadding;
  let $_yPadding;
  let $_xPadding;
  let $_rReverse;
  let $_zReverse;
  let $_yReverse;
  let $_xReverse;
  let $_rNice;
  let $_zNice;
  let $_yNice;
  let $_xNice;
  let $_rDomain;
  let $_zDomain;
  let $_yDomain;
  let $_xDomain;
  let $_r;
  let $_z;
  let $_y;
  let $_x;
  let $_padding;
  let $_flatData;
  let $_data;
  let $_extents;
  let $_containerHeight;
  let $_containerWidth;
  let $_percentRange;
  let $width_d;
  let $height_d;
  let $aspectRatio_d;
  let $padding_d;
  let $extents_d;
  let $xDomain_d;
  let $yDomain_d;
  let $zDomain_d;
  let $rDomain_d;
  let $xRange_d;
  let $yRange_d;
  let $zRange_d;
  let $rRange_d;
  let $xGet_d;
  let $yGet_d;
  let $zGet_d;
  let $rGet_d;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LayerCake", slots, ["default"]);
  const printDebug_debounced = debounce(printDebug, 200);
  let { ssr = false } = $$props;
  let { pointerEvents = true } = $$props;
  let { position = "relative" } = $$props;
  let { percentRange = false } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { containerWidth = width || 100 } = $$props;
  let { containerHeight = height || 100 } = $$props;
  let { element: element2 = void 0 } = $$props;
  let { x: x2 = void 0 } = $$props;
  let { y: y2 = void 0 } = $$props;
  let { z = void 0 } = $$props;
  let { r = void 0 } = $$props;
  let { data = [] } = $$props;
  let { xDomain = void 0 } = $$props;
  let { yDomain = void 0 } = $$props;
  let { zDomain = void 0 } = $$props;
  let { rDomain = void 0 } = $$props;
  let { xNice = false } = $$props;
  let { yNice = false } = $$props;
  let { zNice = false } = $$props;
  let { rNice = false } = $$props;
  let { xPadding = void 0 } = $$props;
  let { yPadding = void 0 } = $$props;
  let { zPadding = void 0 } = $$props;
  let { rPadding = void 0 } = $$props;
  let { xScale = defaultScales_default.x } = $$props;
  let { yScale = defaultScales_default.y } = $$props;
  let { zScale = defaultScales_default.z } = $$props;
  let { rScale = defaultScales_default.r } = $$props;
  let { xRange = void 0 } = $$props;
  let { yRange = void 0 } = $$props;
  let { zRange = void 0 } = $$props;
  let { rRange = void 0 } = $$props;
  let { xReverse = false } = $$props;
  let { yReverse = void 0 } = $$props;
  let { zReverse = false } = $$props;
  let { rReverse = false } = $$props;
  let { padding = {} } = $$props;
  let { extents = {} } = $$props;
  let { flatData = void 0 } = $$props;
  let { custom: custom8 = {} } = $$props;
  let { debug = false } = $$props;
  let isMounted = false;
  onMount(() => {
    isMounted = true;
  });
  const config = {};
  const _percentRange = writable(percentRange);
  validate_store(_percentRange, "_percentRange");
  component_subscribe($$self, _percentRange, (value) => $$invalidate(33, $_percentRange = value));
  const _containerWidth = writable(containerWidth);
  validate_store(_containerWidth, "_containerWidth");
  component_subscribe($$self, _containerWidth, (value) => $$invalidate(32, $_containerWidth = value));
  const _containerHeight = writable(containerHeight);
  validate_store(_containerHeight, "_containerHeight");
  component_subscribe($$self, _containerHeight, (value) => $$invalidate(31, $_containerHeight = value));
  const _extents = writable(filterObject(extents));
  validate_store(_extents, "_extents");
  component_subscribe($$self, _extents, (value) => $$invalidate(170, $_extents = value));
  const _data = writable(data);
  validate_store(_data, "_data");
  component_subscribe($$self, _data, (value) => $$invalidate(30, $_data = value));
  const _flatData = writable(flatData || data);
  validate_store(_flatData, "_flatData");
  component_subscribe($$self, _flatData, (value) => $$invalidate(29, $_flatData = value));
  const _padding = writable(padding);
  validate_store(_padding, "_padding");
  component_subscribe($$self, _padding, (value) => $$invalidate(169, $_padding = value));
  const _x = writable(makeAccessor(x2));
  validate_store(_x, "_x");
  component_subscribe($$self, _x, (value) => $$invalidate(28, $_x = value));
  const _y = writable(makeAccessor(y2));
  validate_store(_y, "_y");
  component_subscribe($$self, _y, (value) => $$invalidate(27, $_y = value));
  const _z = writable(makeAccessor(z));
  validate_store(_z, "_z");
  component_subscribe($$self, _z, (value) => $$invalidate(26, $_z = value));
  const _r = writable(makeAccessor(r));
  validate_store(_r, "_r");
  component_subscribe($$self, _r, (value) => $$invalidate(25, $_r = value));
  const _xDomain = writable(xDomain);
  validate_store(_xDomain, "_xDomain");
  component_subscribe($$self, _xDomain, (value) => $$invalidate(168, $_xDomain = value));
  const _yDomain = writable(yDomain);
  validate_store(_yDomain, "_yDomain");
  component_subscribe($$self, _yDomain, (value) => $$invalidate(167, $_yDomain = value));
  const _zDomain = writable(zDomain);
  validate_store(_zDomain, "_zDomain");
  component_subscribe($$self, _zDomain, (value) => $$invalidate(166, $_zDomain = value));
  const _rDomain = writable(rDomain);
  validate_store(_rDomain, "_rDomain");
  component_subscribe($$self, _rDomain, (value) => $$invalidate(165, $_rDomain = value));
  const _xNice = writable(xNice);
  validate_store(_xNice, "_xNice");
  component_subscribe($$self, _xNice, (value) => $$invalidate(24, $_xNice = value));
  const _yNice = writable(yNice);
  validate_store(_yNice, "_yNice");
  component_subscribe($$self, _yNice, (value) => $$invalidate(23, $_yNice = value));
  const _zNice = writable(zNice);
  validate_store(_zNice, "_zNice");
  component_subscribe($$self, _zNice, (value) => $$invalidate(22, $_zNice = value));
  const _rNice = writable(rNice);
  validate_store(_rNice, "_rNice");
  component_subscribe($$self, _rNice, (value) => $$invalidate(21, $_rNice = value));
  const _xReverse = writable(xReverse);
  validate_store(_xReverse, "_xReverse");
  component_subscribe($$self, _xReverse, (value) => $$invalidate(20, $_xReverse = value));
  const _yReverse = writable(yReverseValue);
  validate_store(_yReverse, "_yReverse");
  component_subscribe($$self, _yReverse, (value) => $$invalidate(19, $_yReverse = value));
  const _zReverse = writable(zReverse);
  validate_store(_zReverse, "_zReverse");
  component_subscribe($$self, _zReverse, (value) => $$invalidate(18, $_zReverse = value));
  const _rReverse = writable(rReverse);
  validate_store(_rReverse, "_rReverse");
  component_subscribe($$self, _rReverse, (value) => $$invalidate(17, $_rReverse = value));
  const _xPadding = writable(xPadding);
  validate_store(_xPadding, "_xPadding");
  component_subscribe($$self, _xPadding, (value) => $$invalidate(16, $_xPadding = value));
  const _yPadding = writable(yPadding);
  validate_store(_yPadding, "_yPadding");
  component_subscribe($$self, _yPadding, (value) => $$invalidate(15, $_yPadding = value));
  const _zPadding = writable(zPadding);
  validate_store(_zPadding, "_zPadding");
  component_subscribe($$self, _zPadding, (value) => $$invalidate(14, $_zPadding = value));
  const _rPadding = writable(rPadding);
  validate_store(_rPadding, "_rPadding");
  component_subscribe($$self, _rPadding, (value) => $$invalidate(13, $_rPadding = value));
  const _xRange = writable(xRange);
  validate_store(_xRange, "_xRange");
  component_subscribe($$self, _xRange, (value) => $$invalidate(164, $_xRange = value));
  const _yRange = writable(yRange);
  validate_store(_yRange, "_yRange");
  component_subscribe($$self, _yRange, (value) => $$invalidate(163, $_yRange = value));
  const _zRange = writable(zRange);
  validate_store(_zRange, "_zRange");
  component_subscribe($$self, _zRange, (value) => $$invalidate(162, $_zRange = value));
  const _rRange = writable(rRange);
  validate_store(_rRange, "_rRange");
  component_subscribe($$self, _rRange, (value) => $$invalidate(161, $_rRange = value));
  const _xScale = writable(xScale);
  validate_store(_xScale, "_xScale");
  component_subscribe($$self, _xScale, (value) => $$invalidate(160, $_xScale = value));
  const _yScale = writable(yScale);
  validate_store(_yScale, "_yScale");
  component_subscribe($$self, _yScale, (value) => $$invalidate(159, $_yScale = value));
  const _zScale = writable(zScale);
  validate_store(_zScale, "_zScale");
  component_subscribe($$self, _zScale, (value) => $$invalidate(158, $_zScale = value));
  const _rScale = writable(rScale);
  validate_store(_rScale, "_rScale");
  component_subscribe($$self, _rScale, (value) => $$invalidate(157, $_rScale = value));
  const _config = writable(config);
  validate_store(_config, "_config");
  component_subscribe($$self, _config, (value) => $$invalidate(11, $_config = value));
  const _custom = writable(custom8);
  validate_store(_custom, "_custom");
  component_subscribe($$self, _custom, (value) => $$invalidate(12, $_custom = value));
  const activeGetters_d = derived([_x, _y, _z, _r], ([$x, $y, $z, $r]) => {
    const obj = {};
    if ($x) {
      obj.x = $x;
    }
    if ($y) {
      obj.y = $y;
    }
    if ($z) {
      obj.z = $z;
    }
    if ($r) {
      obj.r = $r;
    }
    return obj;
  });
  validate_store(activeGetters_d, "activeGetters_d");
  component_subscribe($$self, activeGetters_d, (value) => $$invalidate(10, $activeGetters_d = value));
  const padding_d = derived([_padding, _containerWidth, _containerHeight], ([$padding]) => {
    const defaultPadding = { top: 0, right: 0, bottom: 0, left: 0 };
    return Object.assign(defaultPadding, $padding);
  });
  validate_store(padding_d, "padding_d");
  component_subscribe($$self, padding_d, (value) => $$invalidate(37, $padding_d = value));
  const box_d = derived([_containerWidth, _containerHeight, padding_d], ([$containerWidth, $containerHeight, $padding]) => {
    const b = {};
    b.top = $padding.top;
    b.right = $containerWidth - $padding.right;
    b.bottom = $containerHeight - $padding.bottom;
    b.left = $padding.left;
    b.width = b.right - b.left;
    b.height = b.bottom - b.top;
    if (b.width <= 0 && isMounted === true) {
      console.warn("[LayerCake] Target div has zero or negative width. Did you forget to set an explicit width in CSS on the container?");
    }
    if (b.height <= 0 && isMounted === true) {
      console.warn("[LayerCake] Target div has zero or negative height. Did you forget to set an explicit height in CSS on the container?");
    }
    return b;
  });
  validate_store(box_d, "box_d");
  component_subscribe($$self, box_d, (value) => $$invalidate(151, $box_d = value));
  const width_d = derived([box_d], ([$box]) => {
    return $box.width;
  });
  validate_store(width_d, "width_d");
  component_subscribe($$self, width_d, (value) => $$invalidate(34, $width_d = value));
  const height_d = derived([box_d], ([$box]) => {
    return $box.height;
  });
  validate_store(height_d, "height_d");
  component_subscribe($$self, height_d, (value) => $$invalidate(35, $height_d = value));
  const extents_d = derived([_flatData, activeGetters_d, _extents, _xScale, _yScale, _rScale, _zScale], ([$flatData, $activeGetters, $extents, $_xScale2, $_yScale2, $_rScale2, $_zScale2]) => {
    const scaleLookup = {
      x: $_xScale2,
      y: $_yScale2,
      r: $_rScale2,
      z: $_zScale2
    };
    const getters = filterObject($activeGetters, $extents);
    const activeScales = Object.fromEntries(Object.keys(getters).map((k2) => [k2, scaleLookup[k2]]));
    if (Object.keys(getters).length > 0) {
      const calculatedExtents = calcScaleExtents($flatData, getters, activeScales);
      return { ...calculatedExtents, ...$extents };
    } else {
      return {};
    }
  });
  validate_store(extents_d, "extents_d");
  component_subscribe($$self, extents_d, (value) => $$invalidate(38, $extents_d = value));
  const xDomain_d = derived([extents_d, _xDomain], calcDomain("x"));
  validate_store(xDomain_d, "xDomain_d");
  component_subscribe($$self, xDomain_d, (value) => $$invalidate(39, $xDomain_d = value));
  const yDomain_d = derived([extents_d, _yDomain], calcDomain("y"));
  validate_store(yDomain_d, "yDomain_d");
  component_subscribe($$self, yDomain_d, (value) => $$invalidate(40, $yDomain_d = value));
  const zDomain_d = derived([extents_d, _zDomain], calcDomain("z"));
  validate_store(zDomain_d, "zDomain_d");
  component_subscribe($$self, zDomain_d, (value) => $$invalidate(41, $zDomain_d = value));
  const rDomain_d = derived([extents_d, _rDomain], calcDomain("r"));
  validate_store(rDomain_d, "rDomain_d");
  component_subscribe($$self, rDomain_d, (value) => $$invalidate(42, $rDomain_d = value));
  const xScale_d = derived(
    [
      _xScale,
      extents_d,
      xDomain_d,
      _xPadding,
      _xNice,
      _xReverse,
      width_d,
      height_d,
      _xRange,
      _percentRange
    ],
    createScale("x")
  );
  validate_store(xScale_d, "xScale_d");
  component_subscribe($$self, xScale_d, (value) => $$invalidate(9, $xScale_d = value));
  const xGet_d = derived([_x, xScale_d], createGetter);
  validate_store(xGet_d, "xGet_d");
  component_subscribe($$self, xGet_d, (value) => $$invalidate(47, $xGet_d = value));
  const yScale_d = derived(
    [
      _yScale,
      extents_d,
      yDomain_d,
      _yPadding,
      _yNice,
      _yReverse,
      width_d,
      height_d,
      _yRange,
      _percentRange
    ],
    createScale("y")
  );
  validate_store(yScale_d, "yScale_d");
  component_subscribe($$self, yScale_d, (value) => $$invalidate(8, $yScale_d = value));
  const yGet_d = derived([_y, yScale_d], createGetter);
  validate_store(yGet_d, "yGet_d");
  component_subscribe($$self, yGet_d, (value) => $$invalidate(48, $yGet_d = value));
  const zScale_d = derived(
    [
      _zScale,
      extents_d,
      zDomain_d,
      _zPadding,
      _zNice,
      _zReverse,
      width_d,
      height_d,
      _zRange,
      _percentRange
    ],
    createScale("z")
  );
  validate_store(zScale_d, "zScale_d");
  component_subscribe($$self, zScale_d, (value) => $$invalidate(7, $zScale_d = value));
  const zGet_d = derived([_z, zScale_d], createGetter);
  validate_store(zGet_d, "zGet_d");
  component_subscribe($$self, zGet_d, (value) => $$invalidate(49, $zGet_d = value));
  const rScale_d = derived(
    [
      _rScale,
      extents_d,
      rDomain_d,
      _rPadding,
      _rNice,
      _rReverse,
      width_d,
      height_d,
      _rRange,
      _percentRange
    ],
    createScale("r")
  );
  validate_store(rScale_d, "rScale_d");
  component_subscribe($$self, rScale_d, (value) => $$invalidate(6, $rScale_d = value));
  const rGet_d = derived([_r, rScale_d], createGetter);
  validate_store(rGet_d, "rGet_d");
  component_subscribe($$self, rGet_d, (value) => $$invalidate(50, $rGet_d = value));
  const xRange_d = derived([xScale_d], getRange);
  validate_store(xRange_d, "xRange_d");
  component_subscribe($$self, xRange_d, (value) => $$invalidate(43, $xRange_d = value));
  const yRange_d = derived([yScale_d], getRange);
  validate_store(yRange_d, "yRange_d");
  component_subscribe($$self, yRange_d, (value) => $$invalidate(44, $yRange_d = value));
  const zRange_d = derived([zScale_d], getRange);
  validate_store(zRange_d, "zRange_d");
  component_subscribe($$self, zRange_d, (value) => $$invalidate(45, $zRange_d = value));
  const rRange_d = derived([rScale_d], getRange);
  validate_store(rRange_d, "rRange_d");
  component_subscribe($$self, rRange_d, (value) => $$invalidate(46, $rRange_d = value));
  const aspectRatio_d = derived([width_d, height_d], ([$width, $height]) => {
    return $width / $height;
  });
  validate_store(aspectRatio_d, "aspectRatio_d");
  component_subscribe($$self, aspectRatio_d, (value) => $$invalidate(36, $aspectRatio_d = value));
  const writable_props = [
    "ssr",
    "pointerEvents",
    "position",
    "percentRange",
    "width",
    "height",
    "containerWidth",
    "containerHeight",
    "element",
    "x",
    "y",
    "z",
    "r",
    "data",
    "xDomain",
    "yDomain",
    "zDomain",
    "rDomain",
    "xNice",
    "yNice",
    "zNice",
    "rNice",
    "xPadding",
    "yPadding",
    "zPadding",
    "rPadding",
    "xScale",
    "yScale",
    "zScale",
    "rScale",
    "xRange",
    "yRange",
    "zRange",
    "rRange",
    "xReverse",
    "yReverse",
    "zReverse",
    "rReverse",
    "padding",
    "extents",
    "flatData",
    "custom",
    "debug"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<LayerCake> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  function div_elementresize_handler() {
    containerWidth = this.clientWidth;
    containerHeight = this.clientHeight;
    $$invalidate(0, containerWidth);
    $$invalidate(1, containerHeight);
  }
  $$self.$$set = ($$props2) => {
    if ("ssr" in $$props2)
      $$invalidate(3, ssr = $$props2.ssr);
    if ("pointerEvents" in $$props2)
      $$invalidate(4, pointerEvents = $$props2.pointerEvents);
    if ("position" in $$props2)
      $$invalidate(5, position = $$props2.position);
    if ("percentRange" in $$props2)
      $$invalidate(111, percentRange = $$props2.percentRange);
    if ("width" in $$props2)
      $$invalidate(112, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(113, height = $$props2.height);
    if ("containerWidth" in $$props2)
      $$invalidate(0, containerWidth = $$props2.containerWidth);
    if ("containerHeight" in $$props2)
      $$invalidate(1, containerHeight = $$props2.containerHeight);
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("x" in $$props2)
      $$invalidate(114, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(115, y2 = $$props2.y);
    if ("z" in $$props2)
      $$invalidate(116, z = $$props2.z);
    if ("r" in $$props2)
      $$invalidate(117, r = $$props2.r);
    if ("data" in $$props2)
      $$invalidate(118, data = $$props2.data);
    if ("xDomain" in $$props2)
      $$invalidate(119, xDomain = $$props2.xDomain);
    if ("yDomain" in $$props2)
      $$invalidate(120, yDomain = $$props2.yDomain);
    if ("zDomain" in $$props2)
      $$invalidate(121, zDomain = $$props2.zDomain);
    if ("rDomain" in $$props2)
      $$invalidate(122, rDomain = $$props2.rDomain);
    if ("xNice" in $$props2)
      $$invalidate(123, xNice = $$props2.xNice);
    if ("yNice" in $$props2)
      $$invalidate(124, yNice = $$props2.yNice);
    if ("zNice" in $$props2)
      $$invalidate(125, zNice = $$props2.zNice);
    if ("rNice" in $$props2)
      $$invalidate(126, rNice = $$props2.rNice);
    if ("xPadding" in $$props2)
      $$invalidate(127, xPadding = $$props2.xPadding);
    if ("yPadding" in $$props2)
      $$invalidate(128, yPadding = $$props2.yPadding);
    if ("zPadding" in $$props2)
      $$invalidate(129, zPadding = $$props2.zPadding);
    if ("rPadding" in $$props2)
      $$invalidate(130, rPadding = $$props2.rPadding);
    if ("xScale" in $$props2)
      $$invalidate(131, xScale = $$props2.xScale);
    if ("yScale" in $$props2)
      $$invalidate(132, yScale = $$props2.yScale);
    if ("zScale" in $$props2)
      $$invalidate(133, zScale = $$props2.zScale);
    if ("rScale" in $$props2)
      $$invalidate(134, rScale = $$props2.rScale);
    if ("xRange" in $$props2)
      $$invalidate(135, xRange = $$props2.xRange);
    if ("yRange" in $$props2)
      $$invalidate(136, yRange = $$props2.yRange);
    if ("zRange" in $$props2)
      $$invalidate(137, zRange = $$props2.zRange);
    if ("rRange" in $$props2)
      $$invalidate(138, rRange = $$props2.rRange);
    if ("xReverse" in $$props2)
      $$invalidate(139, xReverse = $$props2.xReverse);
    if ("yReverse" in $$props2)
      $$invalidate(140, yReverse = $$props2.yReverse);
    if ("zReverse" in $$props2)
      $$invalidate(141, zReverse = $$props2.zReverse);
    if ("rReverse" in $$props2)
      $$invalidate(142, rReverse = $$props2.rReverse);
    if ("padding" in $$props2)
      $$invalidate(143, padding = $$props2.padding);
    if ("extents" in $$props2)
      $$invalidate(144, extents = $$props2.extents);
    if ("flatData" in $$props2)
      $$invalidate(145, flatData = $$props2.flatData);
    if ("custom" in $$props2)
      $$invalidate(146, custom8 = $$props2.custom);
    if ("debug" in $$props2)
      $$invalidate(147, debug = $$props2.debug);
    if ("$$scope" in $$props2)
      $$invalidate(152, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    onMount,
    writable,
    derived,
    makeAccessor,
    filterObject,
    debounce,
    calcScaleExtents,
    calcDomain,
    createScale,
    createGetter,
    getRange,
    printDebug,
    defaultScales: defaultScales_default,
    printDebug_debounced,
    ssr,
    pointerEvents,
    position,
    percentRange,
    width,
    height,
    containerWidth,
    containerHeight,
    element: element2,
    x: x2,
    y: y2,
    z,
    r,
    data,
    xDomain,
    yDomain,
    zDomain,
    rDomain,
    xNice,
    yNice,
    zNice,
    rNice,
    xPadding,
    yPadding,
    zPadding,
    rPadding,
    xScale,
    yScale,
    zScale,
    rScale,
    xRange,
    yRange,
    zRange,
    rRange,
    xReverse,
    yReverse,
    zReverse,
    rReverse,
    padding,
    extents,
    flatData,
    custom: custom8,
    debug,
    isMounted,
    config,
    _percentRange,
    _containerWidth,
    _containerHeight,
    _extents,
    _data,
    _flatData,
    _padding,
    _x,
    _y,
    _z,
    _r,
    _xDomain,
    _yDomain,
    _zDomain,
    _rDomain,
    _xNice,
    _yNice,
    _zNice,
    _rNice,
    _xReverse,
    _yReverse,
    _zReverse,
    _rReverse,
    _xPadding,
    _yPadding,
    _zPadding,
    _rPadding,
    _xRange,
    _yRange,
    _zRange,
    _rRange,
    _xScale,
    _yScale,
    _zScale,
    _rScale,
    _config,
    _custom,
    activeGetters_d,
    padding_d,
    box_d,
    width_d,
    height_d,
    extents_d,
    xDomain_d,
    yDomain_d,
    zDomain_d,
    rDomain_d,
    xScale_d,
    xGet_d,
    yScale_d,
    yGet_d,
    zScale_d,
    zGet_d,
    rScale_d,
    rGet_d,
    xRange_d,
    yRange_d,
    zRange_d,
    rRange_d,
    aspectRatio_d,
    context,
    yReverseValue,
    $rScale_d,
    $zScale_d,
    $yScale_d,
    $xScale_d,
    $activeGetters_d,
    $box_d,
    $_config,
    $_custom,
    $_rScale,
    $_zScale,
    $_yScale,
    $_xScale,
    $_rRange,
    $_zRange,
    $_yRange,
    $_xRange,
    $_rPadding,
    $_zPadding,
    $_yPadding,
    $_xPadding,
    $_rReverse,
    $_zReverse,
    $_yReverse,
    $_xReverse,
    $_rNice,
    $_zNice,
    $_yNice,
    $_xNice,
    $_rDomain,
    $_zDomain,
    $_yDomain,
    $_xDomain,
    $_r,
    $_z,
    $_y,
    $_x,
    $_padding,
    $_flatData,
    $_data,
    $_extents,
    $_containerHeight,
    $_containerWidth,
    $_percentRange,
    $width_d,
    $height_d,
    $aspectRatio_d,
    $padding_d,
    $extents_d,
    $xDomain_d,
    $yDomain_d,
    $zDomain_d,
    $rDomain_d,
    $xRange_d,
    $yRange_d,
    $zRange_d,
    $rRange_d,
    $xGet_d,
    $yGet_d,
    $zGet_d,
    $rGet_d
  });
  $$self.$inject_state = ($$props2) => {
    if ("ssr" in $$props2)
      $$invalidate(3, ssr = $$props2.ssr);
    if ("pointerEvents" in $$props2)
      $$invalidate(4, pointerEvents = $$props2.pointerEvents);
    if ("position" in $$props2)
      $$invalidate(5, position = $$props2.position);
    if ("percentRange" in $$props2)
      $$invalidate(111, percentRange = $$props2.percentRange);
    if ("width" in $$props2)
      $$invalidate(112, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(113, height = $$props2.height);
    if ("containerWidth" in $$props2)
      $$invalidate(0, containerWidth = $$props2.containerWidth);
    if ("containerHeight" in $$props2)
      $$invalidate(1, containerHeight = $$props2.containerHeight);
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("x" in $$props2)
      $$invalidate(114, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(115, y2 = $$props2.y);
    if ("z" in $$props2)
      $$invalidate(116, z = $$props2.z);
    if ("r" in $$props2)
      $$invalidate(117, r = $$props2.r);
    if ("data" in $$props2)
      $$invalidate(118, data = $$props2.data);
    if ("xDomain" in $$props2)
      $$invalidate(119, xDomain = $$props2.xDomain);
    if ("yDomain" in $$props2)
      $$invalidate(120, yDomain = $$props2.yDomain);
    if ("zDomain" in $$props2)
      $$invalidate(121, zDomain = $$props2.zDomain);
    if ("rDomain" in $$props2)
      $$invalidate(122, rDomain = $$props2.rDomain);
    if ("xNice" in $$props2)
      $$invalidate(123, xNice = $$props2.xNice);
    if ("yNice" in $$props2)
      $$invalidate(124, yNice = $$props2.yNice);
    if ("zNice" in $$props2)
      $$invalidate(125, zNice = $$props2.zNice);
    if ("rNice" in $$props2)
      $$invalidate(126, rNice = $$props2.rNice);
    if ("xPadding" in $$props2)
      $$invalidate(127, xPadding = $$props2.xPadding);
    if ("yPadding" in $$props2)
      $$invalidate(128, yPadding = $$props2.yPadding);
    if ("zPadding" in $$props2)
      $$invalidate(129, zPadding = $$props2.zPadding);
    if ("rPadding" in $$props2)
      $$invalidate(130, rPadding = $$props2.rPadding);
    if ("xScale" in $$props2)
      $$invalidate(131, xScale = $$props2.xScale);
    if ("yScale" in $$props2)
      $$invalidate(132, yScale = $$props2.yScale);
    if ("zScale" in $$props2)
      $$invalidate(133, zScale = $$props2.zScale);
    if ("rScale" in $$props2)
      $$invalidate(134, rScale = $$props2.rScale);
    if ("xRange" in $$props2)
      $$invalidate(135, xRange = $$props2.xRange);
    if ("yRange" in $$props2)
      $$invalidate(136, yRange = $$props2.yRange);
    if ("zRange" in $$props2)
      $$invalidate(137, zRange = $$props2.zRange);
    if ("rRange" in $$props2)
      $$invalidate(138, rRange = $$props2.rRange);
    if ("xReverse" in $$props2)
      $$invalidate(139, xReverse = $$props2.xReverse);
    if ("yReverse" in $$props2)
      $$invalidate(140, yReverse = $$props2.yReverse);
    if ("zReverse" in $$props2)
      $$invalidate(141, zReverse = $$props2.zReverse);
    if ("rReverse" in $$props2)
      $$invalidate(142, rReverse = $$props2.rReverse);
    if ("padding" in $$props2)
      $$invalidate(143, padding = $$props2.padding);
    if ("extents" in $$props2)
      $$invalidate(144, extents = $$props2.extents);
    if ("flatData" in $$props2)
      $$invalidate(145, flatData = $$props2.flatData);
    if ("custom" in $$props2)
      $$invalidate(146, custom8 = $$props2.custom);
    if ("debug" in $$props2)
      $$invalidate(147, debug = $$props2.debug);
    if ("isMounted" in $$props2)
      isMounted = $$props2.isMounted;
    if ("context" in $$props2)
      $$invalidate(149, context = $$props2.context);
    if ("yReverseValue" in $$props2)
      $$invalidate(150, yReverseValue = $$props2.yReverseValue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[4] & 65792) {
      $:
        $$invalidate(150, yReverseValue = typeof yReverse === "undefined" ? typeof yScale.bandwidth === "function" ? false : true : yReverse);
    }
    if ($$self.$$.dirty[3] & 2097152) {
      $:
        if (x2)
          $$invalidate(148, config.x = x2, config);
    }
    if ($$self.$$.dirty[3] & 4194304) {
      $:
        if (y2)
          $$invalidate(148, config.y = y2, config);
    }
    if ($$self.$$.dirty[3] & 8388608) {
      $:
        if (z)
          $$invalidate(148, config.z = z, config);
    }
    if ($$self.$$.dirty[3] & 16777216) {
      $:
        if (r)
          $$invalidate(148, config.r = r, config);
    }
    if ($$self.$$.dirty[3] & 67108864) {
      $:
        if (xDomain)
          $$invalidate(148, config.xDomain = xDomain, config);
    }
    if ($$self.$$.dirty[3] & 134217728) {
      $:
        if (yDomain)
          $$invalidate(148, config.yDomain = yDomain, config);
    }
    if ($$self.$$.dirty[3] & 268435456) {
      $:
        if (zDomain)
          $$invalidate(148, config.zDomain = zDomain, config);
    }
    if ($$self.$$.dirty[3] & 536870912) {
      $:
        if (rDomain)
          $$invalidate(148, config.rDomain = rDomain, config);
    }
    if ($$self.$$.dirty[4] & 2048) {
      $:
        if (xRange)
          $$invalidate(148, config.xRange = xRange, config);
    }
    if ($$self.$$.dirty[4] & 4096) {
      $:
        if (yRange)
          $$invalidate(148, config.yRange = yRange, config);
    }
    if ($$self.$$.dirty[4] & 8192) {
      $:
        if (zRange)
          $$invalidate(148, config.zRange = zRange, config);
    }
    if ($$self.$$.dirty[4] & 16384) {
      $:
        if (rRange)
          $$invalidate(148, config.rRange = rRange, config);
    }
    if ($$self.$$.dirty[3] & 262144) {
      $:
        set_store_value(_percentRange, $_percentRange = percentRange, $_percentRange);
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        set_store_value(_containerWidth, $_containerWidth = containerWidth, $_containerWidth);
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        set_store_value(_containerHeight, $_containerHeight = containerHeight, $_containerHeight);
    }
    if ($$self.$$.dirty[4] & 1048576) {
      $:
        set_store_value(_extents, $_extents = filterObject(extents), $_extents);
    }
    if ($$self.$$.dirty[3] & 33554432) {
      $:
        set_store_value(_data, $_data = data, $_data);
    }
    if ($$self.$$.dirty[3] & 33554432 | $$self.$$.dirty[4] & 2097152) {
      $:
        set_store_value(_flatData, $_flatData = flatData || data, $_flatData);
    }
    if ($$self.$$.dirty[4] & 524288) {
      $:
        set_store_value(_padding, $_padding = padding, $_padding);
    }
    if ($$self.$$.dirty[3] & 2097152) {
      $:
        set_store_value(_x, $_x = makeAccessor(x2), $_x);
    }
    if ($$self.$$.dirty[3] & 4194304) {
      $:
        set_store_value(_y, $_y = makeAccessor(y2), $_y);
    }
    if ($$self.$$.dirty[3] & 8388608) {
      $:
        set_store_value(_z, $_z = makeAccessor(z), $_z);
    }
    if ($$self.$$.dirty[3] & 16777216) {
      $:
        set_store_value(_r, $_r = makeAccessor(r), $_r);
    }
    if ($$self.$$.dirty[3] & 67108864) {
      $:
        set_store_value(_xDomain, $_xDomain = xDomain, $_xDomain);
    }
    if ($$self.$$.dirty[3] & 134217728) {
      $:
        set_store_value(_yDomain, $_yDomain = yDomain, $_yDomain);
    }
    if ($$self.$$.dirty[3] & 268435456) {
      $:
        set_store_value(_zDomain, $_zDomain = zDomain, $_zDomain);
    }
    if ($$self.$$.dirty[3] & 536870912) {
      $:
        set_store_value(_rDomain, $_rDomain = rDomain, $_rDomain);
    }
    if ($$self.$$.dirty[3] & 1073741824) {
      $:
        set_store_value(_xNice, $_xNice = xNice, $_xNice);
    }
    if ($$self.$$.dirty[4] & 1) {
      $:
        set_store_value(_yNice, $_yNice = yNice, $_yNice);
    }
    if ($$self.$$.dirty[4] & 2) {
      $:
        set_store_value(_zNice, $_zNice = zNice, $_zNice);
    }
    if ($$self.$$.dirty[4] & 4) {
      $:
        set_store_value(_rNice, $_rNice = rNice, $_rNice);
    }
    if ($$self.$$.dirty[4] & 32768) {
      $:
        set_store_value(_xReverse, $_xReverse = xReverse, $_xReverse);
    }
    if ($$self.$$.dirty[4] & 67108864) {
      $:
        set_store_value(_yReverse, $_yReverse = yReverseValue, $_yReverse);
    }
    if ($$self.$$.dirty[4] & 131072) {
      $:
        set_store_value(_zReverse, $_zReverse = zReverse, $_zReverse);
    }
    if ($$self.$$.dirty[4] & 262144) {
      $:
        set_store_value(_rReverse, $_rReverse = rReverse, $_rReverse);
    }
    if ($$self.$$.dirty[4] & 8) {
      $:
        set_store_value(_xPadding, $_xPadding = xPadding, $_xPadding);
    }
    if ($$self.$$.dirty[4] & 16) {
      $:
        set_store_value(_yPadding, $_yPadding = yPadding, $_yPadding);
    }
    if ($$self.$$.dirty[4] & 32) {
      $:
        set_store_value(_zPadding, $_zPadding = zPadding, $_zPadding);
    }
    if ($$self.$$.dirty[4] & 64) {
      $:
        set_store_value(_rPadding, $_rPadding = rPadding, $_rPadding);
    }
    if ($$self.$$.dirty[4] & 2048) {
      $:
        set_store_value(_xRange, $_xRange = xRange, $_xRange);
    }
    if ($$self.$$.dirty[4] & 4096) {
      $:
        set_store_value(_yRange, $_yRange = yRange, $_yRange);
    }
    if ($$self.$$.dirty[4] & 8192) {
      $:
        set_store_value(_zRange, $_zRange = zRange, $_zRange);
    }
    if ($$self.$$.dirty[4] & 16384) {
      $:
        set_store_value(_rRange, $_rRange = rRange, $_rRange);
    }
    if ($$self.$$.dirty[4] & 128) {
      $:
        set_store_value(_xScale, $_xScale = xScale, $_xScale);
    }
    if ($$self.$$.dirty[4] & 256) {
      $:
        set_store_value(_yScale, $_yScale = yScale, $_yScale);
    }
    if ($$self.$$.dirty[4] & 512) {
      $:
        set_store_value(_zScale, $_zScale = zScale, $_zScale);
    }
    if ($$self.$$.dirty[4] & 1024) {
      $:
        set_store_value(_rScale, $_rScale = rScale, $_rScale);
    }
    if ($$self.$$.dirty[4] & 4194304) {
      $:
        set_store_value(_custom, $_custom = custom8, $_custom);
    }
    if ($$self.$$.dirty[4] & 16777216) {
      $:
        set_store_value(_config, $_config = config, $_config);
    }
    if ($$self.$$.dirty[4] & 33554432) {
      $:
        setContext("LayerCake", context);
    }
    if ($$self.$$.dirty[0] & 1992 | $$self.$$.dirty[4] & 159383552) {
      $:
        if ($box_d && debug === true && (ssr === true || typeof window !== "undefined")) {
          printDebug_debounced({
            boundingBox: $box_d,
            activeGetters: $activeGetters_d,
            x: config.x,
            y: config.y,
            z: config.z,
            r: config.r,
            xScale: $xScale_d,
            yScale: $yScale_d,
            zScale: $zScale_d,
            rScale: $rScale_d
          });
        }
    }
  };
  $:
    $$invalidate(149, context = {
      activeGetters: activeGetters_d,
      width: width_d,
      height: height_d,
      percentRange: _percentRange,
      aspectRatio: aspectRatio_d,
      containerWidth: _containerWidth,
      containerHeight: _containerHeight,
      x: _x,
      y: _y,
      z: _z,
      r: _r,
      custom: _custom,
      data: _data,
      xNice: _xNice,
      yNice: _yNice,
      zNice: _zNice,
      rNice: _rNice,
      xReverse: _xReverse,
      yReverse: _yReverse,
      zReverse: _zReverse,
      rReverse: _rReverse,
      xPadding: _xPadding,
      yPadding: _yPadding,
      zPadding: _zPadding,
      rPadding: _rPadding,
      padding: padding_d,
      flatData: _flatData,
      extents: extents_d,
      xDomain: xDomain_d,
      yDomain: yDomain_d,
      zDomain: zDomain_d,
      rDomain: rDomain_d,
      xRange: xRange_d,
      yRange: yRange_d,
      zRange: zRange_d,
      rRange: rRange_d,
      config: _config,
      xScale: xScale_d,
      xGet: xGet_d,
      yScale: yScale_d,
      yGet: yGet_d,
      zScale: zScale_d,
      zGet: zGet_d,
      rScale: rScale_d,
      rGet: rGet_d
    });
  return [
    containerWidth,
    containerHeight,
    element2,
    ssr,
    pointerEvents,
    position,
    $rScale_d,
    $zScale_d,
    $yScale_d,
    $xScale_d,
    $activeGetters_d,
    $_config,
    $_custom,
    $_rPadding,
    $_zPadding,
    $_yPadding,
    $_xPadding,
    $_rReverse,
    $_zReverse,
    $_yReverse,
    $_xReverse,
    $_rNice,
    $_zNice,
    $_yNice,
    $_xNice,
    $_r,
    $_z,
    $_y,
    $_x,
    $_flatData,
    $_data,
    $_containerHeight,
    $_containerWidth,
    $_percentRange,
    $width_d,
    $height_d,
    $aspectRatio_d,
    $padding_d,
    $extents_d,
    $xDomain_d,
    $yDomain_d,
    $zDomain_d,
    $rDomain_d,
    $xRange_d,
    $yRange_d,
    $zRange_d,
    $rRange_d,
    $xGet_d,
    $yGet_d,
    $zGet_d,
    $rGet_d,
    _percentRange,
    _containerWidth,
    _containerHeight,
    _extents,
    _data,
    _flatData,
    _padding,
    _x,
    _y,
    _z,
    _r,
    _xDomain,
    _yDomain,
    _zDomain,
    _rDomain,
    _xNice,
    _yNice,
    _zNice,
    _rNice,
    _xReverse,
    _yReverse,
    _zReverse,
    _rReverse,
    _xPadding,
    _yPadding,
    _zPadding,
    _rPadding,
    _xRange,
    _yRange,
    _zRange,
    _rRange,
    _xScale,
    _yScale,
    _zScale,
    _rScale,
    _config,
    _custom,
    activeGetters_d,
    padding_d,
    box_d,
    width_d,
    height_d,
    extents_d,
    xDomain_d,
    yDomain_d,
    zDomain_d,
    rDomain_d,
    xScale_d,
    xGet_d,
    yScale_d,
    yGet_d,
    zScale_d,
    zGet_d,
    rScale_d,
    rGet_d,
    xRange_d,
    yRange_d,
    zRange_d,
    rRange_d,
    aspectRatio_d,
    percentRange,
    width,
    height,
    x2,
    y2,
    z,
    r,
    data,
    xDomain,
    yDomain,
    zDomain,
    rDomain,
    xNice,
    yNice,
    zNice,
    rNice,
    xPadding,
    yPadding,
    zPadding,
    rPadding,
    xScale,
    yScale,
    zScale,
    rScale,
    xRange,
    yRange,
    zRange,
    rRange,
    xReverse,
    yReverse,
    zReverse,
    rReverse,
    padding,
    extents,
    flatData,
    custom8,
    debug,
    config,
    context,
    yReverseValue,
    $box_d,
    $$scope,
    slots,
    div_binding,
    div_elementresize_handler
  ];
}
var LayerCake = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        ssr: 3,
        pointerEvents: 4,
        position: 5,
        percentRange: 111,
        width: 112,
        height: 113,
        containerWidth: 0,
        containerHeight: 1,
        element: 2,
        x: 114,
        y: 115,
        z: 116,
        r: 117,
        data: 118,
        xDomain: 119,
        yDomain: 120,
        zDomain: 121,
        rDomain: 122,
        xNice: 123,
        yNice: 124,
        zNice: 125,
        rNice: 126,
        xPadding: 127,
        yPadding: 128,
        zPadding: 129,
        rPadding: 130,
        xScale: 131,
        yScale: 132,
        zScale: 133,
        rScale: 134,
        xRange: 135,
        yRange: 136,
        zRange: 137,
        rRange: 138,
        xReverse: 139,
        yReverse: 140,
        zReverse: 141,
        rReverse: 142,
        padding: 143,
        extents: 144,
        flatData: 145,
        custom: 146,
        debug: 147
      },
      add_css,
      [-1, -1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LayerCake",
      options,
      id: create_fragment.name
    });
  }
  get ssr() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ssr(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get percentRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set percentRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerWidth() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerWidth(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerHeight() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerHeight(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get z() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set z(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get r() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set r(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xDomain() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xDomain(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yDomain() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yDomain(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zDomain() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zDomain(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rDomain() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rDomain(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xNice() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xNice(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yNice() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yNice(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zNice() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zNice(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rNice() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rNice(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xPadding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xPadding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yPadding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yPadding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zPadding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zPadding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rPadding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rPadding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xScale() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xScale(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yScale() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yScale(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zScale() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zScale(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rScale() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rScale(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rRange() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rRange(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xReverse() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xReverse(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yReverse() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yReverse(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zReverse() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zReverse(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rReverse() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rReverse(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get extents() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set extents(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flatData() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flatData(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get custom() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set custom(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debug() {
    throw new Error("<LayerCake>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debug(value) {
    throw new Error("<LayerCake>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LayerCake_default = LayerCake;

// node_modules/layercake/dist/layouts/Html.svelte
var file2 = "node_modules/layercake/dist/layouts/Html.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1bu60uu", "div.svelte-1bu60uu,slot.svelte-1bu60uu{position:absolute;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSHRtbC5zdmVsdGUiLCJzb3VyY2VzIjpbIkh0bWwuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cblx0QGNvbXBvbmVudFxuXHRIVE1MIGxheW91dCBjb21wb25lbnRcbiAtLT5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGNvbnN0IHsgcGFkZGluZyB9ID0gZ2V0Q29udGV4dCgnTGF5ZXJDYWtlJyk7XG5cblx0LyoqIEB0eXBlIHtFbGVtZW50fSBbZWxlbWVudF0gVGhlIGxheWVyJ3Mgb3V0ZXJtb3N0IGA8ZGl2PmAgdGFnLiBVc2VmdWwgZm9yIGJpbmRpbmdzLiAqL1xuXHRleHBvcnQgbGV0IGVsZW1lbnQgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtOdW1iZXJ9IFt6SW5kZXhdIFRoZSBsYXllcidzIHotaW5kZXguICovXG5cdGV4cG9ydCBsZXQgekluZGV4ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gW3BvaW50ZXJFdmVudHNdIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZTtgIG9uIHRoZSBlbnRpcmUgbGF5ZXIuICovXG5cdGV4cG9ydCBsZXQgcG9pbnRlckV2ZW50cyA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1N0cmluZ30gW3JvbGVdIEEgc3RyaW5nIHBhc3NlZCB0byB0aGUgYGFyaWEtcm9sZWAgb24gdGhlIGA8ZGl2PmAgdGFnLiBUaGlzIGlzIGB1bmRlZmluZWRgIGJ5IGRlZmF1bHQgYnV0IHdpbGwgYmUgc2V0IGJ5IGRlZmF1bHQgdG8gYCdmaWd1cmUnYCBpZiBgbGFiZWxgLCBgbGFiZWxsZWRieWAgb3IgYGRlc2NyaWJlZGJ5YCBpcyBzZXQuIFRoYXQgZGVmYXVsdCB3aWxsIGJlIG92ZXJyaWRkZW4gYnkgd2hhdGV2ZXIgaXMgcGFzc2VkIGluLiAqL1xuXHRleHBvcnQgbGV0IHJvbGUgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtTdHJpbmd9IFtsYWJlbF0gQSBzdHJpbmcgcGFzc2VkIHRvIHRoZSBgYXJpYS1sYWJlbGAgb24gdGhlIGA8ZGl2PmAgdGFnLiAqL1xuXHRleHBvcnQgbGV0IGxhYmVsID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfSBbbGFiZWxsZWRCeV0gQSBzdHJpbmcgcGFzc2VkIHRvIHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBvbiB0aGUgYDxkaXY+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgbGFiZWxsZWRCeSA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1N0cmluZ30gW2Rlc2NyaWJlZEJ5XSBBIHN0cmluZyBwYXNzZWQgdG8gYGFyaWEtZGVzY3JpYmVkYnlgIHByb3BlcnR5IG9uIHRoZSBgPGRpdj5gIHRhZy4gKi9cblx0ZXhwb3J0IGxldCBkZXNjcmliZWRCeSA9IHVuZGVmaW5lZDtcblxuXHQkOiByb2xlVmFsID0gcm9sZSB8fCAobGFiZWwgfHwgbGFiZWxsZWRCeSB8fCBkZXNjcmliZWRCeSA/ICdmaWd1cmUnIDogdW5kZWZpbmVkKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG5cdGJpbmQ6dGhpcz17ZWxlbWVudH1cblx0Y2xhc3M9XCJsYXllcmNha2UtbGF5b3V0LWh0bWxcIlxuXHRzdHlsZTp6LWluZGV4PXt6SW5kZXh9XG5cdHN0eWxlOnBvaW50ZXItZXZlbnRzPXtwb2ludGVyRXZlbnRzID09PSBmYWxzZSA/ICdub25lJyA6IG51bGx9XG5cdHN0eWxlOnRvcD17JHBhZGRpbmcudG9wICsgJ3B4J31cblx0c3R5bGU6cmlnaHQ9eyRwYWRkaW5nLnJpZ2h0ICsgJ3B4J31cblx0c3R5bGU6Ym90dG9tPXskcGFkZGluZy5ib3R0b20gKyAncHgnfVxuXHRzdHlsZTpsZWZ0PXskcGFkZGluZy5sZWZ0ICsgJ3B4J31cblx0cm9sZT17cm9sZVZhbH1cblx0YXJpYS1sYWJlbD17bGFiZWx9XG5cdGFyaWEtbGFiZWxsZWRieT17bGFiZWxsZWRCeX1cblx0YXJpYS1kZXNjcmliZWRieT17ZGVzY3JpYmVkQnl9XG4+XG5cdDxzbG90IHtlbGVtZW50fT48L3Nsb3Q+XG48L2Rpdj5cblxuPHN0eWxlPlxuXHRkaXYsXG5cdHNsb3Qge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0fVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFtREMsa0JBQUcsQ0FDSCxtQkFBSyxDQUNKLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQ1AifQ== */");
}
var get_default_slot_changes2 = (dirty) => ({ element: dirty & 1 });
var get_default_slot_context2 = (ctx) => ({ element: ctx[0] });
function create_fragment2(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], get_default_slot_context2);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "layercake-layout-html svelte-1bu60uu");
      attr_dev(div, "role", ctx[6]);
      attr_dev(div, "aria-label", ctx[3]);
      attr_dev(div, "aria-labelledby", ctx[4]);
      attr_dev(div, "aria-describedby", ctx[5]);
      set_style(div, "z-index", ctx[1]);
      set_style(div, "pointer-events", ctx[2] === false ? "none" : null);
      set_style(div, "top", ctx[7].top + "px");
      set_style(div, "right", ctx[7].right + "px");
      set_style(div, "bottom", ctx[7].bottom + "px");
      set_style(div, "left", ctx[7].left + "px");
      add_location(div, file2, 33, 0, 1287);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[12](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1025)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, get_default_slot_changes2),
            get_default_slot_context2
          );
        }
      }
      if (!current || dirty & 64) {
        attr_dev(div, "role", ctx2[6]);
      }
      if (!current || dirty & 8) {
        attr_dev(div, "aria-label", ctx2[3]);
      }
      if (!current || dirty & 16) {
        attr_dev(div, "aria-labelledby", ctx2[4]);
      }
      if (!current || dirty & 32) {
        attr_dev(div, "aria-describedby", ctx2[5]);
      }
      if (dirty & 2) {
        set_style(div, "z-index", ctx2[1]);
      }
      if (dirty & 4) {
        set_style(div, "pointer-events", ctx2[2] === false ? "none" : null);
      }
      if (dirty & 128) {
        set_style(div, "top", ctx2[7].top + "px");
      }
      if (dirty & 128) {
        set_style(div, "right", ctx2[7].right + "px");
      }
      if (dirty & 128) {
        set_style(div, "bottom", ctx2[7].bottom + "px");
      }
      if (dirty & 128) {
        set_style(div, "left", ctx2[7].left + "px");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let roleVal;
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Html", slots, ["default"]);
  const { padding } = getContext("LayerCake");
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(7, $padding = value));
  let { element: element2 = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { role = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  const writable_props = [
    "element",
    "zIndex",
    "pointerEvents",
    "role",
    "label",
    "labelledBy",
    "describedBy"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Html> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(1, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(2, pointerEvents = $$props2.pointerEvents);
    if ("role" in $$props2)
      $$invalidate(9, role = $$props2.role);
    if ("label" in $$props2)
      $$invalidate(3, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(4, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(5, describedBy = $$props2.describedBy);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    padding,
    element: element2,
    zIndex,
    pointerEvents,
    role,
    label,
    labelledBy,
    describedBy,
    roleVal,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(1, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(2, pointerEvents = $$props2.pointerEvents);
    if ("role" in $$props2)
      $$invalidate(9, role = $$props2.role);
    if ("label" in $$props2)
      $$invalidate(3, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(4, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(5, describedBy = $$props2.describedBy);
    if ("roleVal" in $$props2)
      $$invalidate(6, roleVal = $$props2.roleVal);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 568) {
      $:
        $$invalidate(6, roleVal = role || (label || labelledBy || describedBy ? "figure" : void 0));
    }
  };
  return [
    element2,
    zIndex,
    pointerEvents,
    label,
    labelledBy,
    describedBy,
    roleVal,
    $padding,
    padding,
    role,
    $$scope,
    slots,
    div_binding
  ];
}
var Html = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        element: 0,
        zIndex: 1,
        pointerEvents: 2,
        role: 9,
        label: 3,
        labelledBy: 4,
        describedBy: 5
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Html",
      options,
      id: create_fragment2.name
    });
  }
  get element() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Html_default = Html;

// node_modules/layercake/dist/layouts/Svg.svelte
var file3 = "node_modules/layercake/dist/layouts/Svg.svelte";
function add_css3(target) {
  append_styles(target, "svelte-u84d8d", "svg.svelte-u84d8d{position:absolute;top:0;left:0;overflow:visible}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZnLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU3ZnLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG5cdEBjb21wb25lbnRcblx0U1ZHIGxheW91dCBjb21wb25lbnRcbiAtLT5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdC8qKiBAdHlwZSB7RWxlbWVudH0gW2VsZW1lbnRdIFRoZSBsYXllcidzIGA8c3ZnPmAgdGFnLiBVc2VmdWwgZm9yIGJpbmRpbmdzLiAqL1xuXHRleHBvcnQgbGV0IGVsZW1lbnQgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtFbGVtZW50fSBbaW5uZXJFbGVtZW50XSBUaGUgbGF5ZXIncyBgPGc+YCB0YWcuIFVzZWZ1bCBmb3IgYmluZGluZ3MuICovXG5cdGV4cG9ydCBsZXQgaW5uZXJFbGVtZW50ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7TnVtYmVyfSBbekluZGV4XSBUaGUgbGF5ZXIncyB6LWluZGV4LiAqL1xuXHRleHBvcnQgbGV0IHpJbmRleCA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge0Jvb2xlYW59IFtwb2ludGVyRXZlbnRzXSBTZXQgdGhpcyB0byBgZmFsc2VgIHRvIHNldCBgcG9pbnRlci1ldmVudHM6IG5vbmU7YCBvbiB0aGUgZW50aXJlIGxheWVyLiAqL1xuXHRleHBvcnQgbGV0IHBvaW50ZXJFdmVudHMgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtTdHJpbmd9IFt2aWV3Qm94XSBBIHN0cmluZyBwYXNzZWQgdG8gdGhlIGB2aWV3Qm94YCBwcm9wZXJ0eSBvbiB0aGUgYDxzdmc+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgdmlld0JveCA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1N0cmluZ30gW2xhYmVsXSBBIHN0cmluZyBwYXNzZWQgdG8gdGhlIGBhcmlhLWxhYmVsYCBwcm9wZXJ0eSBvbiB0aGUgYDxzdmc+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtTdHJpbmd9IFtsYWJlbGxlZEJ5XSBBIHN0cmluZyBwYXNzZWQgdG8gdGhlIGBhcmlhLWxhYmVsbGVkYnkgcHJvcGVydHlgIG9uIHRoZSBgPHN2Zz5gIHRhZy4gKi9cblx0ZXhwb3J0IGxldCBsYWJlbGxlZEJ5ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfSBbZGVzY3JpYmVkQnldIEEgc3RyaW5nIHBhc3NlZCB0byB0aGUgYGFyaWEtZGVzY3JpYmVkYnlgIHByb3BlcnR5IG9uIHRoZSBgPHN2Zz5gIHRhZy4gKi9cblx0ZXhwb3J0IGxldCBkZXNjcmliZWRCeSA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1N0cmluZ30gW3RpdGxlXSBTaG9ydGhhbmQgdG8gc2V0IHRoZSBjb250ZW50cyBvZiBgPHRpdGxlPjwvdGl0bGU+YCBmb3IgYWNjZXNzaWJpbGl0eS4gWW91IGNhbiBhbHNvIHNldCBhcmJpdHJhcnkgSFRNTCB2aWEgdGhlIFwidGl0bGVcIiBzbG90IGJ1dCB0aGlzIGlzIGEgY29udmVuaWVudCBzaG9ydGhhbmQuIElmIHlvdSB1c2UgdGhlIFwidGl0bGVcIiBzbG90LCB0aGlzIHByb3AgaXMgaWdub3JlZC4gKi9cblx0ZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZDtcblxuXHRjb25zdCB7IGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQsIHBhZGRpbmcgfSA9IGdldENvbnRleHQoJ0xheWVyQ2FrZScpO1xuPC9zY3JpcHQ+XG5cbjxzdmdcblx0YmluZDp0aGlzPXtlbGVtZW50fVxuXHRjbGFzcz1cImxheWVyY2FrZS1sYXlvdXQtc3ZnXCJcblx0e3ZpZXdCb3h9XG5cdHdpZHRoPXskY29udGFpbmVyV2lkdGh9XG5cdGhlaWdodD17JGNvbnRhaW5lckhlaWdodH1cblx0c3R5bGU6ei1pbmRleD17ekluZGV4fVxuXHRzdHlsZTpwb2ludGVyLWV2ZW50cz17cG9pbnRlckV2ZW50cyA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsfVxuXHRhcmlhLWxhYmVsPXtsYWJlbH1cblx0YXJpYS1sYWJlbGxlZGJ5PXtsYWJlbGxlZEJ5fVxuXHRhcmlhLWRlc2NyaWJlZGJ5PXtkZXNjcmliZWRCeX1cbj5cblx0PHNsb3QgbmFtZT1cInRpdGxlXCI+eyNpZiB0aXRsZX08dGl0bGU+e3RpdGxlfTwvdGl0bGU+ey9pZn08L3Nsb3Q+XG5cblx0PGRlZnM+XG5cdFx0PHNsb3QgbmFtZT1cImRlZnNcIj48L3Nsb3Q+XG5cdDwvZGVmcz5cblx0PGdcblx0XHRiaW5kOnRoaXM9e2lubmVyRWxlbWVudH1cblx0XHRjbGFzcz1cImxheWVyY2FrZS1sYXlvdXQtc3ZnX2dcIlxuXHRcdHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7JHBhZGRpbmcubGVmdH0sIHskcGFkZGluZy50b3B9KVwiPlxuXHRcdDxzbG90IHtlbGVtZW50fT48L3Nsb3Q+XG5cdDwvZz5cbjwvc3ZnPlxuXG48c3R5bGU+XG5cdHN2ZyB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHRcdG92ZXJmbG93OiB2aXNpYmxlO1xuXHR9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQStEQyxpQkFBSSxDQUNILFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxRQUFRLENBQUUsT0FDWCJ9 */");
}
var get_default_slot_changes3 = (dirty) => ({ element: dirty & 1 });
var get_default_slot_context3 = (ctx) => ({ element: ctx[0] });
var get_defs_slot_changes = (dirty) => ({ element: dirty & 1 });
var get_defs_slot_context = (ctx) => ({ element: ctx[0] });
var get_title_slot_changes = (dirty) => ({ element: dirty & 1 });
var get_title_slot_context = (ctx) => ({ element: ctx[0] });
function create_if_block2(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[8]);
      add_location(title_1, file3, 49, 31, 1797);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 256)
        set_data_dev(t, ctx2[8]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(50:20) {#if title}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let if_block_anchor;
  let if_block = ctx[8] && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(50:20) {#if title}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let svg;
  let defs;
  let g;
  let g_transform_value;
  let current;
  const title_slot_template = ctx[16].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[15], get_title_slot_context);
  const title_slot_or_fallback = title_slot || fallback_block(ctx);
  const defs_slot_template = ctx[16].defs;
  const defs_slot = create_slot(defs_slot_template, ctx, ctx[15], get_defs_slot_context);
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], get_default_slot_context3);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      defs = svg_element("defs");
      if (defs_slot)
        defs_slot.c();
      g = svg_element("g");
      if (default_slot)
        default_slot.c();
      add_location(defs, file3, 51, 1, 1834);
      attr_dev(g, "class", "layercake-layout-svg_g");
      attr_dev(g, "transform", g_transform_value = "translate(" + ctx[11].left + ", " + ctx[11].top + ")");
      add_location(g, file3, 54, 1, 1879);
      attr_dev(svg, "class", "layercake-layout-svg svelte-u84d8d");
      attr_dev(svg, "viewBox", ctx[4]);
      attr_dev(svg, "width", ctx[9]);
      attr_dev(svg, "height", ctx[10]);
      attr_dev(svg, "aria-label", ctx[5]);
      attr_dev(svg, "aria-labelledby", ctx[6]);
      attr_dev(svg, "aria-describedby", ctx[7]);
      set_style(svg, "z-index", ctx[2]);
      set_style(svg, "pointer-events", ctx[3] === false ? "none" : null);
      add_location(svg, file3, 37, 0, 1475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(svg, null);
      }
      append_dev(svg, defs);
      if (defs_slot) {
        defs_slot.m(defs, null);
      }
      append_dev(svg, g);
      if (default_slot) {
        default_slot.m(g, null);
      }
      ctx[17](g);
      ctx[18](svg);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 32769)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(title_slot_template, ctx2[15], dirty, get_title_slot_changes),
            get_title_slot_context
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & 256)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (defs_slot) {
        if (defs_slot.p && (!current || dirty & 32769)) {
          update_slot_base(
            defs_slot,
            defs_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(defs_slot_template, ctx2[15], dirty, get_defs_slot_changes),
            get_defs_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32769)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, get_default_slot_changes3),
            get_default_slot_context3
          );
        }
      }
      if (!current || dirty & 2048 && g_transform_value !== (g_transform_value = "translate(" + ctx2[11].left + ", " + ctx2[11].top + ")")) {
        attr_dev(g, "transform", g_transform_value);
      }
      if (!current || dirty & 16) {
        attr_dev(svg, "viewBox", ctx2[4]);
      }
      if (!current || dirty & 512) {
        attr_dev(svg, "width", ctx2[9]);
      }
      if (!current || dirty & 1024) {
        attr_dev(svg, "height", ctx2[10]);
      }
      if (!current || dirty & 32) {
        attr_dev(svg, "aria-label", ctx2[5]);
      }
      if (!current || dirty & 64) {
        attr_dev(svg, "aria-labelledby", ctx2[6]);
      }
      if (!current || dirty & 128) {
        attr_dev(svg, "aria-describedby", ctx2[7]);
      }
      if (dirty & 4) {
        set_style(svg, "z-index", ctx2[2]);
      }
      if (dirty & 8) {
        set_style(svg, "pointer-events", ctx2[3] === false ? "none" : null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      transition_in(defs_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      transition_out(defs_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if (defs_slot)
        defs_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[17](null);
      ctx[18](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $containerWidth;
  let $containerHeight;
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Svg", slots, ["title", "defs", "default"]);
  let { element: element2 = void 0 } = $$props;
  let { innerElement = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { viewBox = void 0 } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  let { title = void 0 } = $$props;
  const { containerWidth, containerHeight, padding } = getContext("LayerCake");
  validate_store(containerWidth, "containerWidth");
  component_subscribe($$self, containerWidth, (value) => $$invalidate(9, $containerWidth = value));
  validate_store(containerHeight, "containerHeight");
  component_subscribe($$self, containerHeight, (value) => $$invalidate(10, $containerHeight = value));
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(11, $padding = value));
  const writable_props = [
    "element",
    "innerElement",
    "zIndex",
    "pointerEvents",
    "viewBox",
    "label",
    "labelledBy",
    "describedBy",
    "title"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Svg> was created with unknown prop '${key}'`);
  });
  function g_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerElement = $$value;
      $$invalidate(1, innerElement);
    });
  }
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("innerElement" in $$props2)
      $$invalidate(1, innerElement = $$props2.innerElement);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("viewBox" in $$props2)
      $$invalidate(4, viewBox = $$props2.viewBox);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    element: element2,
    innerElement,
    zIndex,
    pointerEvents,
    viewBox,
    label,
    labelledBy,
    describedBy,
    title,
    containerWidth,
    containerHeight,
    padding,
    $containerWidth,
    $containerHeight,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("innerElement" in $$props2)
      $$invalidate(1, innerElement = $$props2.innerElement);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("viewBox" in $$props2)
      $$invalidate(4, viewBox = $$props2.viewBox);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    innerElement,
    zIndex,
    pointerEvents,
    viewBox,
    label,
    labelledBy,
    describedBy,
    title,
    $containerWidth,
    $containerHeight,
    $padding,
    containerWidth,
    containerHeight,
    padding,
    $$scope,
    slots,
    g_binding,
    svg_binding
  ];
}
var Svg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        element: 0,
        innerElement: 1,
        zIndex: 2,
        pointerEvents: 3,
        viewBox: 4,
        label: 5,
        labelledBy: 6,
        describedBy: 7,
        title: 8
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Svg",
      options,
      id: create_fragment3.name
    });
  }
  get element() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get innerElement() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set innerElement(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewBox() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewBox(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Svg_default = Svg;

// node_modules/layercake/dist/layouts/ScaledSvg.svelte
var file4 = "node_modules/layercake/dist/layouts/ScaledSvg.svelte";
function add_css4(target) {
  append_styles(target, "svelte-6sm8ei", "svg.svelte-6sm8ei{position:absolute;width:100%;height:100%;overflow:visible}svg.svelte-6sm8ei *{vector-effect:non-scaling-stroke}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NhbGVkU3ZnLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU2NhbGVkU3ZnLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG5cdEBjb21wb25lbnRcblx0U2NhbGVkIFNWRyBsYXlvdXQgY29tcG9uZW50XG4gLS0+XG48c2NyaXB0PlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuXHRjb25zdCB7IHBhZGRpbmcgfSA9IGdldENvbnRleHQoJ0xheWVyQ2FrZScpO1xuXG5cdC8qKiBAdHlwZSB7RWxlbWVudH0gW2VsZW1lbnRdIFRoZSBsYXllcidzIGA8c3ZnPmAgdGFnLiBVc2VmdWwgZm9yIGJpbmRpbmdzLiAqL1xuXHRleHBvcnQgbGV0IGVsZW1lbnQgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtOdW1iZXJ9IFt6SW5kZXhdIFRoZSBsYXllcidzIHotaW5kZXguICovXG5cdGV4cG9ydCBsZXQgekluZGV4ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gW3BvaW50ZXJFdmVudHNdIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZTtgIG9uIHRoZSBlbnRpcmUgbGF5ZXIuICovXG5cdGV4cG9ydCBsZXQgcG9pbnRlckV2ZW50cyA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge051bWJlcn0gW2ZpeGVkQXNwZWN0UmF0aW89MWBdIEEgbnVtYmVyIHRvIHNldCB0aGUgYXNwZWN0IHJhdGlvIG9udG8gdGhlIHZpZXdCb3guICovXG5cdGV4cG9ydCBsZXQgZml4ZWRBc3BlY3RSYXRpbyA9IDE7XG5cblx0LyoqIEB0eXBlIHtTdHJpbmd9IFt2aWV3Qm94PWAwIDAgMTAwICR7MTAwIC8gZml4ZWRBc3BlY3RSYXRpb31gXSBBIHN0cmluZyBwYXNzZWQgdG8gdGhlIGB2aWV3Qm94YCBwcm9wZXJ0eSBvbiB0aGUgYDxzdmc+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgdmlld0JveCA9IGAwIDAgMTAwICR7MTAwIC8gZml4ZWRBc3BlY3RSYXRpb31gO1xuXHQkOiB2aWV3Qm94ID0gYDAgMCAxMDAgJHsxMDAgLyBmaXhlZEFzcGVjdFJhdGlvfWA7XG5cblx0LyoqIEB0eXBlIHtTdHJpbmd9IFtsYWJlbF0gQSBzdHJpbmcgcGFzc2VkIHRvIHRoZSBgYXJpYS1sYWJlbGAgb24gdGhlIGA8c3ZnPmAgdGFnLiAqL1xuXHRleHBvcnQgbGV0IGxhYmVsID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfSBbbGFiZWxsZWRCeV0gQSBzdHJpbmcgcGFzc2VkIHRvIHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBvbiB0aGUgYDxzdmc+YCB0YWcuICovXG5cdGV4cG9ydCBsZXQgbGFiZWxsZWRCeSA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1N0cmluZ30gW2Rlc2NyaWJlZEJ5XSBBIHN0cmluZyBwYXNzZWQgdG8gYGFyaWEtZGVzY3JpYmVkYnlgIHByb3BlcnR5IG9uIHRoZSBgPHN2Zz5gIHRhZy4gKi9cblx0ZXhwb3J0IGxldCBkZXNjcmliZWRCeSA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1N0cmluZ30gW3RpdGxlXSBTaG9ydGhhbmQgdG8gc2V0IHRoZSBjb250ZW50cyBvZiBgPHRpdGxlPjwvdGl0bGU+YCBmb3IgYWNjZXNzaWJpbGl0eS4gWW91IGNhbiBhbHNvIHNldCBhcmJpdHJhcnkgSFRNTCB2aWEgdGhlIFwidGl0bGVcIiBzbG90IGJ1dCB0aGlzIGlzIGEgY29udmVuaWVudCBzaG9ydGhhbmQuIElmIHlvdSB1c2UgdGhlIFwidGl0bGVcIiBzbG90LCB0aGlzIHByb3AgaXMgaWdub3JlZC4gKi9cblx0ZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZDtcbjwvc2NyaXB0PlxuXG48c3ZnXG5cdGJpbmQ6dGhpcz17ZWxlbWVudH1cblx0e3ZpZXdCb3h9XG5cdHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCJcblx0c3R5bGU6ei1pbmRleD17ekluZGV4fVxuXHRzdHlsZTpwb2ludGVyLWV2ZW50cz17cG9pbnRlckV2ZW50cyA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsfVxuXHRzdHlsZTp0b3A9eyRwYWRkaW5nLnRvcCArICdweCd9XG5cdHN0eWxlOmxlZnQ9eyRwYWRkaW5nLmxlZnQgKyAncHgnfVxuXHRzdHlsZTp3aWR0aD17YGNhbGMoMTAwJSAtICR7KCRwYWRkaW5nLmxlZnQgKyAkcGFkZGluZy5yaWdodCl9cHgpYH1cblx0c3R5bGU6aGVpZ2h0PXtgY2FsYygxMDAlIC0gJHsoJHBhZGRpbmcudG9wICsgJHBhZGRpbmcuYm90dG9tKX1weClgfVxuXHRzdHlsZT1cInJpZ2h0OjBweDsgYm90dG9tOjBweDtcIlxuXHRhcmlhLWxhYmVsPXtsYWJlbH1cblx0YXJpYS1sYWJlbGxlZGJ5PXtsYWJlbGxlZEJ5fVxuXHRhcmlhLWRlc2NyaWJlZGJ5PXtkZXNjcmliZWRCeX1cbj5cblx0PHNsb3QgbmFtZT1cInRpdGxlXCI+eyNpZiB0aXRsZX08dGl0bGU+e3RpdGxlfTwvdGl0bGU+ey9pZn08L3Nsb3Q+XG5cblx0PGRlZnM+XG5cdFx0PHNsb3QgbmFtZT1cImRlZnNcIj48L3Nsb3Q+XG5cdDwvZGVmcz5cblxuXHQ8c2xvdCB7ZWxlbWVudH0+PC9zbG90PlxuPC9zdmc+XG5cbjxzdHlsZT5cblx0c3ZnIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdG92ZXJmbG93OiB2aXNpYmxlO1xuXHR9XG5cdHN2ZyA6Z2xvYmFsKCopIHtcblx0XHR2ZWN0b3ItZWZmZWN0OiBub24tc2NhbGluZy1zdHJva2U7XG5cdH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBK0RDLGlCQUFJLENBQ0gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxPQUNYLENBQ0EsaUJBQUcsQ0FBUyxDQUFHLENBQ2QsYUFBYSxDQUFFLGtCQUNoQiJ9 */");
}
var get_default_slot_changes4 = (dirty) => ({ element: dirty & 1 });
var get_default_slot_context4 = (ctx) => ({ element: ctx[0] });
var get_defs_slot_changes2 = (dirty) => ({ element: dirty & 1 });
var get_defs_slot_context2 = (ctx) => ({ element: ctx[0] });
var get_title_slot_changes2 = (dirty) => ({ element: dirty & 1 });
var get_title_slot_context2 = (ctx) => ({ element: ctx[0] });
function create_if_block3(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[7]);
      add_location(title_1, file4, 53, 31, 2054);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 128)
        set_data_dev(t, ctx2[7]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(54:20) {#if title}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let if_block_anchor;
  let if_block = ctx[7] && create_if_block3(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(54:20) {#if title}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let svg;
  let defs;
  let current;
  const title_slot_template = ctx[12].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[11], get_title_slot_context2);
  const title_slot_or_fallback = title_slot || fallback_block2(ctx);
  const defs_slot_template = ctx[12].defs;
  const defs_slot = create_slot(defs_slot_template, ctx, ctx[11], get_defs_slot_context2);
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], get_default_slot_context4);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      defs = svg_element("defs");
      if (defs_slot)
        defs_slot.c();
      if (default_slot)
        default_slot.c();
      add_location(defs, file4, 55, 1, 2091);
      attr_dev(svg, "viewBox", ctx[1]);
      attr_dev(svg, "preserveAspectRatio", "none");
      set_style(svg, "right", "0px");
      set_style(svg, "bottom", "0px");
      attr_dev(svg, "aria-label", ctx[4]);
      attr_dev(svg, "aria-labelledby", ctx[5]);
      attr_dev(svg, "aria-describedby", ctx[6]);
      attr_dev(svg, "class", "svelte-6sm8ei");
      set_style(svg, "z-index", ctx[2]);
      set_style(svg, "pointer-events", ctx[3] === false ? "none" : null);
      set_style(svg, "top", ctx[8].top + "px");
      set_style(svg, "left", ctx[8].left + "px");
      set_style(svg, "width", `calc(100% - ${ctx[8].left + ctx[8].right}px)`);
      set_style(svg, "height", `calc(100% - ${ctx[8].top + ctx[8].bottom}px)`);
      add_location(svg, file4, 38, 0, 1549);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(svg, null);
      }
      append_dev(svg, defs);
      if (defs_slot) {
        defs_slot.m(defs, null);
      }
      if (default_slot) {
        default_slot.m(svg, null);
      }
      ctx[13](svg);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 2049)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(title_slot_template, ctx2[11], dirty, get_title_slot_changes2),
            get_title_slot_context2
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & 128)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (defs_slot) {
        if (defs_slot.p && (!current || dirty & 2049)) {
          update_slot_base(
            defs_slot,
            defs_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(defs_slot_template, ctx2[11], dirty, get_defs_slot_changes2),
            get_defs_slot_context2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2049)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, get_default_slot_changes4),
            get_default_slot_context4
          );
        }
      }
      if (!current || dirty & 2) {
        attr_dev(svg, "viewBox", ctx2[1]);
      }
      if (!current || dirty & 16) {
        attr_dev(svg, "aria-label", ctx2[4]);
      }
      if (!current || dirty & 32) {
        attr_dev(svg, "aria-labelledby", ctx2[5]);
      }
      if (!current || dirty & 64) {
        attr_dev(svg, "aria-describedby", ctx2[6]);
      }
      if (dirty & 4) {
        set_style(svg, "z-index", ctx2[2]);
      }
      if (dirty & 8) {
        set_style(svg, "pointer-events", ctx2[3] === false ? "none" : null);
      }
      if (dirty & 256) {
        set_style(svg, "top", ctx2[8].top + "px");
      }
      if (dirty & 256) {
        set_style(svg, "left", ctx2[8].left + "px");
      }
      if (dirty & 256) {
        set_style(svg, "width", `calc(100% - ${ctx2[8].left + ctx2[8].right}px)`);
      }
      if (dirty & 256) {
        set_style(svg, "height", `calc(100% - ${ctx2[8].top + ctx2[8].bottom}px)`);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      transition_in(defs_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      transition_out(defs_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if (defs_slot)
        defs_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[13](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScaledSvg", slots, ["title", "defs", "default"]);
  const { padding } = getContext("LayerCake");
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(8, $padding = value));
  let { element: element2 = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { fixedAspectRatio = 1 } = $$props;
  let { viewBox = `0 0 100 ${100 / fixedAspectRatio}` } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  let { title = void 0 } = $$props;
  const writable_props = [
    "element",
    "zIndex",
    "pointerEvents",
    "fixedAspectRatio",
    "viewBox",
    "label",
    "labelledBy",
    "describedBy",
    "title"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScaledSvg> was created with unknown prop '${key}'`);
  });
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("fixedAspectRatio" in $$props2)
      $$invalidate(10, fixedAspectRatio = $$props2.fixedAspectRatio);
    if ("viewBox" in $$props2)
      $$invalidate(1, viewBox = $$props2.viewBox);
    if ("label" in $$props2)
      $$invalidate(4, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(5, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(6, describedBy = $$props2.describedBy);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(11, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    padding,
    element: element2,
    zIndex,
    pointerEvents,
    fixedAspectRatio,
    viewBox,
    label,
    labelledBy,
    describedBy,
    title,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("fixedAspectRatio" in $$props2)
      $$invalidate(10, fixedAspectRatio = $$props2.fixedAspectRatio);
    if ("viewBox" in $$props2)
      $$invalidate(1, viewBox = $$props2.viewBox);
    if ("label" in $$props2)
      $$invalidate(4, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(5, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(6, describedBy = $$props2.describedBy);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(1, viewBox = `0 0 100 ${100 / fixedAspectRatio}`);
    }
  };
  return [
    element2,
    viewBox,
    zIndex,
    pointerEvents,
    label,
    labelledBy,
    describedBy,
    title,
    $padding,
    padding,
    fixedAspectRatio,
    $$scope,
    slots,
    svg_binding
  ];
}
var ScaledSvg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        element: 0,
        zIndex: 2,
        pointerEvents: 3,
        fixedAspectRatio: 10,
        viewBox: 1,
        label: 4,
        labelledBy: 5,
        describedBy: 6,
        title: 7
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScaledSvg",
      options,
      id: create_fragment4.name
    });
  }
  get element() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixedAspectRatio() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixedAspectRatio(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewBox() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewBox(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ScaledSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ScaledSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScaledSvg_default = ScaledSvg;

// node_modules/layercake/dist/lib/scaleCanvas.js
function scaleCanvas_default(ctx, width, height) {
  const dpr = window.devicePixelRatio || 1;
  ctx.canvas.width = width * dpr;
  ctx.canvas.height = height * dpr;
  ctx.canvas.style.width = `${width}px`;
  ctx.canvas.style.height = `${height}px`;
  ctx.scale(dpr, dpr);
  return { width: ctx.canvas.width, height: ctx.canvas.height };
}

// node_modules/layercake/dist/layouts/Canvas.svelte
var file5 = "node_modules/layercake/dist/layouts/Canvas.svelte";
var get_default_slot_changes5 = (dirty) => ({
  element: dirty & 2,
  context: dirty & 1
});
var get_default_slot_context5 = (ctx) => ({
  element: ctx[1],
  context: ctx[0]
});
var get_fallback_slot_changes = (dirty) => ({
  element: dirty & 2,
  context: dirty & 1
});
var get_fallback_slot_context = (ctx) => ({
  element: ctx[1],
  context: ctx[0]
});
function create_if_block4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(62:23) {#if fallback}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let if_block_anchor;
  let if_block = ctx[4] && create_if_block4(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(62:23) {#if fallback}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let canvas;
  let t;
  let current;
  const fallback_slot_template = ctx[13].fallback;
  const fallback_slot = create_slot(fallback_slot_template, ctx, ctx[12], get_fallback_slot_context);
  const fallback_slot_or_fallback = fallback_slot || fallback_block3(ctx);
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], get_default_slot_context5);
  const block = {
    c: function create() {
      canvas = element("canvas");
      if (fallback_slot_or_fallback)
        fallback_slot_or_fallback.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(canvas, "class", "layercake-layout-canvas");
      set_style(canvas, "width", "100%");
      set_style(canvas, "height", "100%");
      set_style(canvas, "position", "absolute");
      attr_dev(canvas, "aria-label", ctx[5]);
      attr_dev(canvas, "aria-labelledby", ctx[6]);
      attr_dev(canvas, "aria-describedby", ctx[7]);
      set_style(canvas, "z-index", ctx[2]);
      set_style(canvas, "pointer-events", ctx[3] === false ? "none" : null);
      set_style(canvas, "top", ctx[8].top + "px");
      set_style(canvas, "right", ctx[8].right + "px");
      set_style(canvas, "bottom", ctx[8].bottom + "px");
      set_style(canvas, "left", ctx[8].left + "px");
      add_location(canvas, file5, 48, 0, 1649);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, canvas, anchor);
      if (fallback_slot_or_fallback) {
        fallback_slot_or_fallback.m(canvas, null);
      }
      ctx[14](canvas);
      insert_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (fallback_slot) {
        if (fallback_slot.p && (!current || dirty & 4099)) {
          update_slot_base(
            fallback_slot,
            fallback_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(fallback_slot_template, ctx2[12], dirty, get_fallback_slot_changes),
            get_fallback_slot_context
          );
        }
      } else {
        if (fallback_slot_or_fallback && fallback_slot_or_fallback.p && (!current || dirty & 16)) {
          fallback_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 32) {
        attr_dev(canvas, "aria-label", ctx2[5]);
      }
      if (!current || dirty & 64) {
        attr_dev(canvas, "aria-labelledby", ctx2[6]);
      }
      if (!current || dirty & 128) {
        attr_dev(canvas, "aria-describedby", ctx2[7]);
      }
      if (dirty & 4) {
        set_style(canvas, "z-index", ctx2[2]);
      }
      if (dirty & 8) {
        set_style(canvas, "pointer-events", ctx2[3] === false ? "none" : null);
      }
      if (dirty & 256) {
        set_style(canvas, "top", ctx2[8].top + "px");
      }
      if (dirty & 256) {
        set_style(canvas, "right", ctx2[8].right + "px");
      }
      if (dirty & 256) {
        set_style(canvas, "bottom", ctx2[8].bottom + "px");
      }
      if (dirty & 256) {
        set_style(canvas, "left", ctx2[8].left + "px");
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4099)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, get_default_slot_changes5),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fallback_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fallback_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(canvas);
      if (fallback_slot_or_fallback)
        fallback_slot_or_fallback.d(detaching);
      ctx[14](null);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let $height;
  let $width;
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Canvas", slots, ["fallback", "default"]);
  const { width, height, padding } = getContext("LayerCake");
  validate_store(width, "width");
  component_subscribe($$self, width, (value) => $$invalidate(16, $width = value));
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(15, $height = value));
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(8, $padding = value));
  let { element: element2 = void 0 } = $$props;
  let { context = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { fallback = "" } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  const cntxt = { ctx: writable({}) };
  onMount(() => {
    $$invalidate(0, context = element2.getContext("2d"));
    scaleCanvas_default(context, $width, $height);
  });
  setContext("canvas", cntxt);
  const writable_props = [
    "element",
    "context",
    "zIndex",
    "pointerEvents",
    "fallback",
    "label",
    "labelledBy",
    "describedBy"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Canvas> was created with unknown prop '${key}'`);
  });
  function canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("fallback" in $$props2)
      $$invalidate(4, fallback = $$props2.fallback);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    setContext,
    writable,
    scaleCanvas: scaleCanvas_default,
    width,
    height,
    padding,
    element: element2,
    context,
    zIndex,
    pointerEvents,
    fallback,
    label,
    labelledBy,
    describedBy,
    cntxt,
    $height,
    $width,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("fallback" in $$props2)
      $$invalidate(4, fallback = $$props2.fallback);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        cntxt.ctx.set(context);
    }
  };
  return [
    context,
    element2,
    zIndex,
    pointerEvents,
    fallback,
    label,
    labelledBy,
    describedBy,
    $padding,
    width,
    height,
    padding,
    $$scope,
    slots,
    canvas_binding
  ];
}
var Canvas = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      element: 1,
      context: 0,
      zIndex: 2,
      pointerEvents: 3,
      fallback: 4,
      label: 5,
      labelledBy: 6,
      describedBy: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Canvas",
      options,
      id: create_fragment5.name
    });
  }
  get element() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallback() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallback(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Canvas_default = Canvas;

// node_modules/layercake/dist/layouts/Webgl.svelte
var file6 = "node_modules/layercake/dist/layouts/Webgl.svelte";
var get_default_slot_changes6 = (dirty) => ({
  element: dirty & 2,
  context: dirty & 1
});
var get_default_slot_context6 = (ctx) => ({
  element: ctx[1],
  context: ctx[0]
});
var get_fallback_slot_changes2 = (dirty) => ({
  element: dirty & 2,
  context: dirty & 1
});
var get_fallback_slot_context2 = (ctx) => ({
  element: ctx[1],
  context: ctx[0]
});
function create_if_block5(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(76:23) {#if fallback}",
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let if_block_anchor;
  let if_block = ctx[4] && create_if_block5(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(76:23) {#if fallback}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let canvas;
  let t;
  let current;
  const fallback_slot_template = ctx[12].fallback;
  const fallback_slot = create_slot(fallback_slot_template, ctx, ctx[11], get_fallback_slot_context2);
  const fallback_slot_or_fallback = fallback_slot || fallback_block4(ctx);
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], get_default_slot_context6);
  const block = {
    c: function create() {
      canvas = element("canvas");
      if (fallback_slot_or_fallback)
        fallback_slot_or_fallback.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(canvas, "class", "layercake-layout-webgl");
      set_style(canvas, "width", "100%");
      set_style(canvas, "height", "100%");
      set_style(canvas, "position", "absolute");
      attr_dev(canvas, "aria-label", ctx[5]);
      attr_dev(canvas, "aria-labelledby", ctx[6]);
      attr_dev(canvas, "aria-describedby", ctx[7]);
      set_style(canvas, "z-index", ctx[2]);
      set_style(canvas, "pointer-events", ctx[3] === false ? "none" : null);
      set_style(canvas, "top", ctx[8].top + "px");
      set_style(canvas, "right", ctx[8].right + "px");
      set_style(canvas, "bottom", ctx[8].bottom + "px");
      set_style(canvas, "left", ctx[8].left + "px");
      add_location(canvas, file6, 62, 0, 2147);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, canvas, anchor);
      if (fallback_slot_or_fallback) {
        fallback_slot_or_fallback.m(canvas, null);
      }
      ctx[13](canvas);
      insert_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (fallback_slot) {
        if (fallback_slot.p && (!current || dirty & 2051)) {
          update_slot_base(
            fallback_slot,
            fallback_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(fallback_slot_template, ctx2[11], dirty, get_fallback_slot_changes2),
            get_fallback_slot_context2
          );
        }
      } else {
        if (fallback_slot_or_fallback && fallback_slot_or_fallback.p && (!current || dirty & 16)) {
          fallback_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 32) {
        attr_dev(canvas, "aria-label", ctx2[5]);
      }
      if (!current || dirty & 64) {
        attr_dev(canvas, "aria-labelledby", ctx2[6]);
      }
      if (!current || dirty & 128) {
        attr_dev(canvas, "aria-describedby", ctx2[7]);
      }
      if (dirty & 4) {
        set_style(canvas, "z-index", ctx2[2]);
      }
      if (dirty & 8) {
        set_style(canvas, "pointer-events", ctx2[3] === false ? "none" : null);
      }
      if (dirty & 256) {
        set_style(canvas, "top", ctx2[8].top + "px");
      }
      if (dirty & 256) {
        set_style(canvas, "right", ctx2[8].right + "px");
      }
      if (dirty & 256) {
        set_style(canvas, "bottom", ctx2[8].bottom + "px");
      }
      if (dirty & 256) {
        set_style(canvas, "left", ctx2[8].left + "px");
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2051)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, get_default_slot_changes6),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fallback_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fallback_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(canvas);
      if (fallback_slot_or_fallback)
        fallback_slot_or_fallback.d(detaching);
      ctx[13](null);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Webgl", slots, ["fallback", "default"]);
  let { element: element2 = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { pointerEvents = void 0 } = $$props;
  let { contextAttributes = void 0 } = $$props;
  let { context = void 0 } = $$props;
  let { fallback = "" } = $$props;
  let { label = void 0 } = $$props;
  let { labelledBy = void 0 } = $$props;
  let { describedBy = void 0 } = $$props;
  let testGl;
  const { padding } = getContext("LayerCake");
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(8, $padding = value));
  const cntxt = { gl: writable({}) };
  onMount(() => {
    const contexts = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
    for (let j = 0; j < contexts.length; j++) {
      testGl = element2.getContext(contexts[j], contextAttributes);
      if (testGl) {
        $$invalidate(0, context = testGl);
        break;
      }
    }
  });
  setContext("gl", cntxt);
  const writable_props = [
    "element",
    "zIndex",
    "pointerEvents",
    "contextAttributes",
    "context",
    "fallback",
    "label",
    "labelledBy",
    "describedBy"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Webgl> was created with unknown prop '${key}'`);
  });
  function canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("contextAttributes" in $$props2)
      $$invalidate(10, contextAttributes = $$props2.contextAttributes);
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("fallback" in $$props2)
      $$invalidate(4, fallback = $$props2.fallback);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("$$scope" in $$props2)
      $$invalidate(11, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    setContext,
    writable,
    element: element2,
    zIndex,
    pointerEvents,
    contextAttributes,
    context,
    fallback,
    label,
    labelledBy,
    describedBy,
    testGl,
    padding,
    cntxt,
    $padding
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("pointerEvents" in $$props2)
      $$invalidate(3, pointerEvents = $$props2.pointerEvents);
    if ("contextAttributes" in $$props2)
      $$invalidate(10, contextAttributes = $$props2.contextAttributes);
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("fallback" in $$props2)
      $$invalidate(4, fallback = $$props2.fallback);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("labelledBy" in $$props2)
      $$invalidate(6, labelledBy = $$props2.labelledBy);
    if ("describedBy" in $$props2)
      $$invalidate(7, describedBy = $$props2.describedBy);
    if ("testGl" in $$props2)
      testGl = $$props2.testGl;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        cntxt.gl.set(context);
    }
  };
  return [
    context,
    element2,
    zIndex,
    pointerEvents,
    fallback,
    label,
    labelledBy,
    describedBy,
    $padding,
    padding,
    contextAttributes,
    $$scope,
    slots,
    canvas_binding
  ];
}
var Webgl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      element: 1,
      zIndex: 2,
      pointerEvents: 3,
      contextAttributes: 10,
      context: 0,
      fallback: 4,
      label: 5,
      labelledBy: 6,
      describedBy: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Webgl",
      options,
      id: create_fragment6.name
    });
  }
  get element() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contextAttributes() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contextAttributes(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallback() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallback(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedBy() {
    throw new Error("<Webgl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedBy(value) {
    throw new Error("<Webgl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Webgl_default = Webgl;

// node_modules/layercake/dist/lib/flatten.js
function flatten(list, accessor = (d) => d) {
  const acc = typeof accessor === "string" ? (d) => d[accessor] : accessor;
  if (Array.isArray(list) && Array.isArray(acc(list[0]))) {
    let flat = [];
    const l = list.length;
    for (let i = 0; i < l; i += 1) {
      flat = flat.concat(acc(list[i]));
    }
    return flat;
  }
  return list;
}

// node_modules/layercake/dist/lib/uniques.js
function uniques(list, accessor, transform = true) {
  if (!Array.isArray(list)) {
    console.error("LayerCake error: Input value to `uniques` must be a list.");
    return null;
  }
  const ll = list.length;
  const iterater = typeof accessor === "function";
  const key = typeof accessor !== "undefined";
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  for (let i = 0; i < ll; i += 1) {
    const d = list[i];
    const computed = iterater ? accessor(d) : key === true ? d[accessor] : d;
    if (!seen.has(computed)) {
      seen.add(computed);
      result.push(transform ? computed : d);
    }
  }
  return result;
}

// node_modules/layercake/dist/lib/raise.js
function raise(el) {
  if (el.nextSibling)
    el.parentNode.appendChild(el);
}

// node_modules/layercake/dist/lib/takeEvery.js
function takeEvery(list, n) {
  if (list.length <= n)
    return list;
  const e = Math.round(list.length / n);
  return list.filter((d, i) => {
    return i % e === 0;
  });
}

// node_modules/layercake/dist/lib/bin.js
function bin2(data, value, {
  domain,
  thresholds
} = {}) {
  if (typeof data !== "object") {
    throw new TypeError("The first argument of bin() must be an array or data object");
  }
  let hist = bin();
  if (value) {
    const acc = typeof value === "function" ? value : (d) => d[value];
    hist = hist.value(acc);
  }
  if (domain) {
    hist = hist.domain(domain);
  }
  if (thresholds) {
    hist = hist.thresholds(thresholds);
  }
  return hist(data);
}

// node_modules/d3-shape/src/constant.js
function constant_default2(x2) {
  return function constant2() {
    return x2;
  };
}

// node_modules/d3-shape/src/math.js
var cos = Math.cos;
var sin = Math.sin;
var sqrt2 = Math.sqrt;
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon3 = 1e-6;
var tauEpsilon = tau2 - epsilon3;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d > 15)
    return append;
  const k2 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon3))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon3) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon3) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon3 || Math.abs(this._y1 - y0) > epsilon3) {
      this._append`L${x0},${y0}`;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau2 + tau2;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon3) {
      this._append`A${r},${r},0,${+(da >= pi2)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w, h) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default2(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r) {
    this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
  }
};
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt2(3);

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt2(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt2(3);

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt2(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = sqrt2(3) / 2;
var k = 1 / sqrt2(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point2(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j = x2.length - 1;
    if (j > 0) {
      var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point4(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point4(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point4(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};

// node_modules/d3-shape/src/curve/monotone.js
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point5(that, t03, t13) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t03, x1 - dx, y1 - dx * t13, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t13 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t13 = slope3(this, x2, y2)), t13);
        break;
      default:
        point5(this, this._t0, t13 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i)
    m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
  if (!((n = series.length) > 1))
    return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0)
    o[n] = n;
  return o;
}

// node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack_default() {
  var keys = constant_default2([]), order = none_default2, offset = none_default, value = stackValue;
  function stack2(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array_default2(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack2.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack2) : keys;
  };
  stack2.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default2(+_), stack2) : value;
  };
  stack2.order = function(_) {
    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack2) : order;
  };
  stack2.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none_default : _, stack2) : offset;
  };
  return stack2;
}

// node_modules/layercake/dist/lib/stack.js
function stack(data, keys, {
  value,
  order,
  offset
} = {}) {
  if (typeof data !== "object") {
    throw new TypeError("The first argument of stack() must be an array or data object");
  }
  if (!Array.isArray(keys)) {
    throw new TypeError("The second argument of stack() must be an array of key names");
  }
  let stacker = stack_default().keys(keys);
  if (value) {
    stacker = stacker.value(value);
  }
  if (order) {
    stacker = stacker.order(order);
  }
  if (offset) {
    stacker = stacker.offset(offset);
  }
  return stacker(data);
}

// node_modules/layercake/dist/lib/groupLonger.js
function groupLonger(data, keys, {
  groupTo = "group",
  valueTo = "value",
  keepKeys = void 0
} = {}) {
  if (!Array.isArray(data)) {
    throw new TypeError("The first argument of groupLonger() must be an array of data");
  }
  if (!Array.isArray(keys)) {
    throw new TypeError("The second argument of groupLonger() must be an array of key names");
  }
  const keysSet = new Set(keys);
  const keep = keepKeys || Object.keys(data[0]).filter((d) => !keysSet.has(d));
  return keys.map((key) => {
    return {
      [groupTo]: key,
      values: data.map((d) => {
        return {
          ...Object.fromEntries(keep.map((k2) => [k2, d[k2]])),
          [valueTo]: d[key],
          [groupTo]: key
        };
      })
    };
  });
}
export {
  Canvas_default as Canvas,
  Html_default as Html,
  LayerCake_default as LayerCake,
  ScaledSvg_default as ScaledSvg,
  Svg_default as Svg,
  Webgl_default as WebGL,
  bin2 as bin,
  calcExtents,
  flatten,
  groupLonger,
  raise,
  scaleCanvas_default as scaleCanvas,
  stack,
  takeEvery,
  uniques
};
//# sourceMappingURL=layercake.js.map
